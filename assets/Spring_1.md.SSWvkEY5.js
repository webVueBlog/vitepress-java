import{_ as a,c as e,o as n,a8 as t}from"./chunks/framework.CbRyzB36.js";const o="/vitepress-java/assets/img.Cz47H-zq.png",i="/vitepress-java/assets/img_1.DS_Tcbsy.png",S=JSON.parse('{"title":"不知道的Spring知识点","description":"","frontmatter":{},"headers":[],"relativePath":"Spring/1.md","filePath":"Spring/1.md"}'),r={name:"Spring/1.md"},s=t('<h1 id="不知道的spring知识点" tabindex="-1">不知道的Spring知识点 <a class="header-anchor" href="#不知道的spring知识点" aria-label="Permalink to &quot;不知道的Spring知识点&quot;">​</a></h1><h2 id="当使用-component-bean的name默认是什么" tabindex="-1">当使用@Component Bean的Name默认是什么？ <a class="header-anchor" href="#当使用-component-bean的name默认是什么" aria-label="Permalink to &quot;当使用@Component Bean的Name默认是什么？&quot;">​</a></h2><p>很多同学觉得Bean的名字不就是类名首字母小写吗？其实并不是全都这样。 在解析@Component注册为BeanDefinition时会调用AnnotationBeanNameGenerator.buildDefaultBeanName</p><p><img src="'+o+'" alt="img.png" loading="lazy"></p><h2 id="单例设计模式与bean单例" tabindex="-1">单例设计模式与Bean单例 <a class="header-anchor" href="#单例设计模式与bean单例" aria-label="Permalink to &quot;单例设计模式与Bean单例&quot;">​</a></h2><p>Singleton模式主要作用是保证在Java应用程序中，一个Class有且仅有一个实例。 它的好处非常显然的，可以避免不必要的重复操作，以及防止踩踏事件。在很多操作中，比如建立目录 数据库连接都需要这样的单线程操作。 一些资源管理器常常设计成单例模式。</p><p>诸如数据库的连接，外部资源中如一台电脑可对应多个端口，但系统会集中管理这些端口，内部资源如采用一个对象管理存放系统配置的一个或多个属性文件。 但是，单例设计模式与Bean单例具有一定的区别，主要在于它们运行环境，java单例设计模式的环境是JVM，而Bean单例的环境在于Bean容器。 一个Spring程序可以有很多个Bean，但一个Java程序通常有且仅有一个自己的JVM。 所以，虽然Spring的Bean单例在一个容器中有且仅有一个，但如果程序具有多个Bean容器， 而且都有某个Bean，那么这个Bean在这个程序中并非只有一个。</p><p>但在实际应用中，如果将对象的生命周期完全交给Spring管理(不在其他地方通过new、反射等方式创建)，其实也能达到单例模式的效果。</p><p><img src="'+i+'" alt="img_1.png" loading="lazy"></p>',9),p=[s];function _(c,l,m,d,g,h){return n(),e("div",null,p)}const f=a(r,[["render",_]]);export{S as __pageData,f as default};
