import{_ as a,c as i,o as l,a8 as t}from"./chunks/framework.CbRyzB36.js";const o="/vitepress-java/assets/img_63.CSxhfPWI.png",e="/vitepress-java/assets/img_64.CNChZ6nk.png",s="/vitepress-java/assets/img_65.Co92eO0A.png",p="/vitepress-java/assets/img_66.CR2rFUxg.png",r="/vitepress-java/assets/img_67.Cl1tRBzo.png",n="/vitepress-java/assets/img_68.C7uwc99k.png",c="/vitepress-java/assets/img_69.BpeNcJXR.png",g="/vitepress-java/assets/img_70.DWTPcDLH.png",_="/vitepress-java/assets/img_71.zJQkyO9H.png",m="/vitepress-java/assets/img_72.62Z-QghM.png",d="/vitepress-java/assets/img_73.D2exfinP.png",u="/vitepress-java/assets/img_74.DNb_WnYs.png",v="/vitepress-java/assets/img_75.DIS5TIP2.png",h="/vitepress-java/assets/img_76.CuPj2jj5.png",x=JSON.parse('{"title":"十、Java 内存模型","description":"","frontmatter":{},"headers":[],"relativePath":"javaConcurrency/memoryModel.md","filePath":"javaConcurrency/memoryModel.md"}'),k={name:"javaConcurrency/memoryModel.md"},b=t('<h1 id="十、java-内存模型" tabindex="-1">十、Java 内存模型 <a class="header-anchor" href="#十、java-内存模型" aria-label="Permalink to &quot;十、Java 内存模型&quot;">​</a></h1><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在 各种平台下都能达到一致的内存访问效果。</p><h2 id="主内存与工作内存" tabindex="-1">主内存与工作内存 <a class="header-anchor" href="#主内存与工作内存" aria-label="Permalink to &quot;主内存与工作内存&quot;">​</a></h2><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它 们之间加入了高速缓存。</p><p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区 域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p><p><img src="'+o+'" alt="img_63.png" loading="lazy"></p><p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速 缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p><p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来 完成</p><p><img src="'+e+'" alt="img_64.png" loading="lazy"></p><h2 id="内存间交互操作" tabindex="-1">内存间交互操作 <a class="header-anchor" href="#内存间交互操作" aria-label="Permalink to &quot;内存间交互操作&quot;">​</a></h2><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p><p><img src="'+s+'" alt="img_65.png" loading="lazy"></p><ul><li>read：把一个变量的值从主内存传输到工作内存中</li><li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：把工作内存中一个变量的值传递给执行引擎</li><li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store：把工作内存的一个变量的值传送到主内存中</li><li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li><li>lock：作用于主内存的变量</li><li>unlock</li></ul><h2 id="内存模型三大特性" tabindex="-1">内存模型三大特性 <a class="header-anchor" href="#内存模型三大特性" aria-label="Permalink to &quot;内存模型三大特性&quot;">​</a></h2><ol><li>原子性</li></ol><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有 原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。 但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double） 的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以 不具备原子性。</p><p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。 前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操 作之后，得到的值为 997 而不是 1000。</p><p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p><p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上 看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然 可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、 assign、store 这些单个操作具备原子性。</p><p><img src="'+p+'" alt="img_66.png" loading="lazy"></p><p>AtomicInteger 能保证多个线程修改的原子性。</p><p><img src="'+r+'" alt="img_67.png" loading="lazy"></p><p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p><p><img src="'+n+'" alt="img_68.png" loading="lazy"></p><p><img src="'+c+'" alt="img_69.png" loading="lazy"></p><p>1000</p><p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应 的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p><p><img src="'+g+'" alt="img_70.png" loading="lazy"></p><p><img src="'+_+'" alt="img_71.png" loading="lazy"></p><p>1000</p><ol start="2"><li>可见性</li></ol><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量 值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li></ul><p>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能 看见 final 字段的值。</p><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问 题，因为 volatile 并不能保证操作的原子性。</p><ol start="3"><li>有序性</li></ol><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程， 所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编 译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影 响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的 指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代 码，相当于是让线程顺序执行同步代码。</p><h2 id="先行发生原则" tabindex="-1">先行发生原则 <a class="header-anchor" href="#先行发生原则" aria-label="Permalink to &quot;先行发生原则&quot;">​</a></h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了 先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><ol><li>单一线程原则</li></ol><blockquote><p>Single Thread rule</p></blockquote><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><p><img src="'+m+'" alt="img_72.png" loading="lazy"></p><ol start="2"><li>管程锁定规则</li></ol><blockquote><p>Monitor Lock Rule</p></blockquote><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><p><img src="'+d+'" alt="img_73.png" loading="lazy"></p><ol start="3"><li>volatile 变量规则</li></ol><blockquote><p>Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><p><img src="'+u+'" alt="img_74.png" loading="lazy"></p><ol start="4"><li>线程启动规则</li></ol><blockquote><p>Thread Start Rule</p></blockquote><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><p><img src="'+v+'" alt="img_75.png" loading="lazy"></p><ol start="5"><li>线程加入规则</li></ol><blockquote><p>Thread Join Rule</p></blockquote><p>Thread 对象的结束先行发生于 join() 方法返回。</p><p><img src="'+h+'" alt="img_76.png" loading="lazy"></p><ol start="6"><li>线程中断规则</li></ol><blockquote><p>Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生， 可以通过 interrupted() 方法检测到是否有中断发生。</p><ol start="7"><li>对象终结规则</li></ol><blockquote><p>Finalizer Rule</p></blockquote><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开 始。</p><ol start="8"><li>传递性</li></ol><blockquote><p>Transitivity</p></blockquote><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于 操作 C。</p>',71),y=[b];function q(j,z,f,T,C,J){return l(),i("div",null,y)}const R=a(k,[["render",q]]);export{x as __pageData,R as default};
