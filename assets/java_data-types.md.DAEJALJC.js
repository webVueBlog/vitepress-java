import{_ as a,c as s,o as e,a8 as n}from"./chunks/framework.CbRyzB36.js";const p="/vitepress-java/assets/img_2.Cx4yqLM-.png",t="/vitepress-java/assets/img_3.CMK0z0Bc.png",i="/vitepress-java/assets/img_4.BbdsF2q9.png",l="/vitepress-java/assets/img_5.CACC7kDD.png",r="/vitepress-java/assets/img_6.D1mGVv8A.png",o="/vitepress-java/assets/img_7.BhoF4o_p.png",c="/vitepress-java/assets/img_8.C61P7g9V.png",g="/vitepress-java/assets/img_9.0hOA6lcy.png",k=JSON.parse('{"title":"一、数据类型","description":"","frontmatter":{},"headers":[],"relativePath":"java/data-types.md","filePath":"java/data-types.md"}'),m={name:"java/data-types.md"},_=n(`<h1 id="一、数据类型" tabindex="-1">一、数据类型 <a class="header-anchor" href="#一、数据类型" aria-label="Permalink to &quot;一、数据类型&quot;">​</a></h1><h2 id="基本类型" tabindex="-1">基本类型 <a class="header-anchor" href="#基本类型" aria-label="Permalink to &quot;基本类型&quot;">​</a></h2><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>byte/8</span></span>
<span class="line"><span>char/16</span></span>
<span class="line"><span>short/16</span></span>
<span class="line"><span>int/32</span></span>
<span class="line"><span>float/32</span></span>
<span class="line"><span>long/64</span></span>
<span class="line"><span>double/64</span></span>
<span class="line"><span>boolean/ ~</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规 定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表 示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p><h2 id="包装类型" tabindex="-1">包装类型 <a class="header-anchor" href="#包装类型" aria-label="Permalink to &quot;包装类型&quot;">​</a></h2><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装 箱与拆箱完成。</p><p><img src="`+p+'" alt="img_2.png" loading="lazy"></p><h2 id="缓存池" tabindex="-1">缓存池 <a class="header-anchor" href="#缓存池" aria-label="Permalink to &quot;缓存池&quot;">​</a></h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ol><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ol><p><img src="'+t+'" alt="img_3.png" loading="lazy"></p><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接 返回缓存池的内容。</p><p><img src="'+i+'" alt="img_4.png" loading="lazy"></p><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><p><img src="'+l+'" alt="img_5.png" loading="lazy"></p><p><img src="'+r+'" alt="img_6.png" loading="lazy"></p><p><img src="'+o+'" alt="img_7.png" loading="lazy"></p><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内 的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><p><img src="'+c+'" alt="img_8.png" loading="lazy"></p><p>基本类型对应的缓冲池如下：</p><h3 id="缓冲池" tabindex="-1">缓冲池 <a class="header-anchor" href="#缓冲池" aria-label="Permalink to &quot;缓冲池&quot;">​</a></h3><p><img src="'+g+'" alt="img_9.png" loading="lazy"></p><p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直 接使用缓冲池中的对象。</p><p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲 池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候， 通过 <code>-XX:AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小，该选项在 JVM 初始 化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初 始化的时候就会读取该系统属性来决定上界。</p>',24),d=[_];function h(b,u,v,f,y,j){return e(),s("div",null,d)}const q=a(m,[["render",h]]);export{k as __pageData,q as default};
