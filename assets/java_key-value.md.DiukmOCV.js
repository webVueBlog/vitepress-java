import{_ as s,c as a,o as n,a8 as l}from"./chunks/framework.DDO5B0CJ.js";const p="/vitepress-java/assets/img_27.DkHaZuxK.png",i="/vitepress-java/assets/img_28.BS4WxXvt.png",t="/vitepress-java/assets/img_29.SKXckyNm.png",e="/vitepress-java/assets/img_30.BxpUGb1y.png",r="/vitepress-java/assets/img_31.Yc8vcCKU.png",o="/vitepress-java/assets/img_32.CPlFCmOR.png",k=JSON.parse('{"title":"四、关键字","description":"","frontmatter":{},"headers":[],"relativePath":"java/key-value.md","filePath":"java/key-value.md"}'),c={name:"java/key-value.md"},m=l('<h1 id="四、关键字" tabindex="-1">四、关键字 <a class="header-anchor" href="#四、关键字" aria-label="Permalink to &quot;四、关键字&quot;">​</a></h1><p>final</p><ol><li>数据</li></ol><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常 量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本</li><li>身是可以修改的。</li></ul><p><img src="'+p+'" alt="img_27.png" loading="lazy"></p><ol start="2"><li>方法</li></ol><p>声明方法不能被子类重写。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方 法。</p><ol start="3"><li>类</li></ol><p>声明类不允许被继承。</p><p>static</p><ol><li>静态变量</li></ol><ul><li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静 态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><p><img src="'+i+'" alt="img_28.png" loading="lazy"></p><ol start="2"><li>静态方法</li></ol><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实 现，也就是说它不能是抽象方法。</p><p><img src="'+t+'" alt="img_29.png" loading="lazy"></p><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这 两个关键字与具体对象关联。</p><p><img src="'+e+'" alt="img_30.png" loading="lazy"></p><ol start="3"><li>静态语句块</li></ol><p>静态语句块在类初始化时运行一次。</p><p><img src="'+r+'" alt="img_31.png" loading="lazy"></p><ol start="4"><li>静态内部类</li></ol><p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实 例去创建非静态内部类。而静态内部类不需要。</p><p><img src="'+o+`" alt="img_32.png" loading="lazy"></p><p>静态内部类不能访问外部类的非静态的变量和方法。</p><ol start="5"><li>静态导包</li></ol><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降 低。</p><p>import static com.xxx.ClassName.*</p><ol start="6"><li>初始化顺序</li></ol><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始 化顺序取决于它们在代码中的顺序。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public static String staticField = &quot;静态变量&quot;;</span></span>
<span class="line"><span>static {</span></span>
<span class="line"><span>System.out.println(&quot;静态语句块&quot;);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>public String field = &quot;实例变量&quot;;</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>System.out.println(&quot;普通语句块&quot;);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>最后才是构造函数的初始化。</span></span>
<span class="line"><span>public InitialOrderTest() {</span></span>
<span class="line"><span>System.out.println(&quot;构造函数&quot;);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul>`,35),u=[m];function _(g,d,b,v,h,y){return n(),a("div",null,u)}const q=s(c,[["render",_]]);export{k as __pageData,q as default};
