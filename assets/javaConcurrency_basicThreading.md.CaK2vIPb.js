import{_ as a,c as e,o as i,a8 as t}from"./chunks/framework.DDO5B0CJ.js";const r="/vitepress-java/assets/img_6.00dnvV-s.png",o="/vitepress-java/assets/img_7.CnXkeaAF.png",s="/vitepress-java/assets/img_8.CAs3vXbL.png",n="/vitepress-java/assets/img_9.D5WFKDy-.png",T=JSON.parse('{"title":"二、基础线程机制","description":"","frontmatter":{},"headers":[],"relativePath":"javaConcurrency/basicThreading.md","filePath":"javaConcurrency/basicThreading.md"}'),l={name:"javaConcurrency/basicThreading.md"},p=t('<h1 id="二、基础线程机制" tabindex="-1">二、基础线程机制 <a class="header-anchor" href="#二、基础线程机制" aria-label="Permalink to &quot;二、基础线程机制&quot;">​</a></h1><h2 id="executor" tabindex="-1">Executor <a class="header-anchor" href="#executor" aria-label="Permalink to &quot;Executor&quot;">​</a></h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里 的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p><p>主要有三种 Executor：</p><ul><li>CachedThreadPool：一个任务创建一个线程；</li><li>FixedThreadPool：所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li></ul><p><img src="'+r+'" alt="img_6.png" loading="lazy"></p><h2 id="daemon" tabindex="-1">Daemon <a class="header-anchor" href="#daemon" aria-label="Permalink to &quot;Daemon&quot;">​</a></h2><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>因此，守护线程通常用于执行支持性工作，比如垃圾回收。</p><h3 id="设置守护线程" tabindex="-1">设置守护线程 <a class="header-anchor" href="#设置守护线程" aria-label="Permalink to &quot;设置守护线程&quot;">​</a></h3><p>main() 属于非守护线程。</p><p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p><p><img src="'+o+'" alt="img_7.png" loading="lazy"></p><h2 id="sleep" tabindex="-1">sleep() <a class="header-anchor" href="#sleep" aria-label="Permalink to &quot;sleep()&quot;">​</a></h2><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因 此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p><p><img src="'+s+'" alt="img_8.png" loading="lazy"></p><h2 id="yield" tabindex="-1">yield() <a class="header-anchor" href="#yield" aria-label="Permalink to &quot;yield()&quot;">​</a></h2><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部 分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是 建议具有相同优先级的其它线程可以运行。</p><p><img src="'+n+'" alt="img_9.png" loading="lazy"></p>',21),c=[p];function d(h,_,m,g,u,x){return i(),e("div",null,c)}const v=a(l,[["render",d]]);export{T as __pageData,v as default};
