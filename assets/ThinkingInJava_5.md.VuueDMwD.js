import{_ as a,c as p,o as e,a8 as t}from"./chunks/framework.DDO5B0CJ.js";const m=JSON.parse('{"title":"第 5 章 隐藏实施过程","description":"","frontmatter":{},"headers":[],"relativePath":"ThinkingInJava/5.md","filePath":"ThinkingInJava/5.md"}'),i={name:"ThinkingInJava/5.md"},r=t('<h1 id="第-5-章-隐藏实施过程" tabindex="-1">第 5 章 隐藏实施过程 <a class="header-anchor" href="#第-5-章-隐藏实施过程" aria-label="Permalink to &quot;第 5 章 隐藏实施过程&quot;">​</a></h1><p>我们用 import关键字导入一个完整的库时，就会获得“包”（Package）。</p><p>“库”也由一系列类文件构成。每个文件都有一个 public类（并没强迫使用一个 public类，但这种情况最 很典型的），所以每个文件都有一个组件。如果想将所有这些组件（它们在各自独立的.java和.class文件 里）都归纳到一起，那么package关键字就可以发挥作用）。</p><p>每次创建一个包后，都在为包取名时间接地指定了一个目录结构。这个包必须存 在（驻留）于由它的名字规定的目录内。而且这个目录必须能从CLASSPATH 开始搜索并发现。最开始的时 候，package关键字的运用可能会令人迷惑，因为除非坚持遵守根据目录路径指定包名的规则，否则就会在 运行期获得大量莫名其妙的消息，指出找不到一个特定的类——即使那个类明明就在相同的目录中。若得到 象这样的一条消息，请试着将 package语句作为注释标记出去。如果这样做行得通，就可知道问题到底出在 哪儿。</p><p>针对类内每个成员的每个定义，Java 访问指示符 poublic，protected以及private都置于它们的最前面— —无论它们是一个数据成员，还是一个方法。每个访问指示符都只控制着对那个特定定义的访问。这与C++ 存在着显著不同。在C++ 中，访问指示符控制着它后面的所有定义，直到又一个访问指示符加入为止。 通过千丝万缕的联系，程序为所有东西都指定了某种形式的访问。</p><p>如果根本不指定访问指示符，就象本章之前的所有例子那样，这时会出现什么情况呢？默认的访问没有关键 字，但它通常称为“友好”（Friendly）访问。这意味着当前包内的其他所有类都能访问“友好的”成员， 但对包外的所有类来说，这些成员却是“私有”（Private）的，外界不得访问。由于一个编译单元（一个文 件）只能从属于单个包，所以单个编译单元内的所有类相互间都是自动“友好”的。因此，我们也说友好元 素拥有“包访问”权限。</p><p>友好访问允许我们将相关的类都组合到一个包里，使它们相互间方便地进行沟通。将类组合到一个包内以后 （这样便允许友好成员的相互访问，亦即让它们“交朋友”），我们便“拥有”了那个包内的代码。只有我 们已经拥有的代码才能友好地访问自己拥有的其他代码。我们可认为友好访问使类在一个包内的组合显得有 意义，或者说前者是后者的原因。在许多语言中，我们在文件内组织定义的方式往往显得有些牵强。但在 Java 中，却强制用一种颇有意义的形式进行组织。除此以外，我们有时可能想排除一些类，不想让它们访问 当前包内定义的类。</p><p>对于任何关系，一个非常重要的问题是“谁能访问我们的‘私有’或 private代码”。类控制着哪些代码能 够访问自己的成员。没有任何秘诀可以“闯入”。另一个包内推荐可以声明一个新类，然后说：“嗨，我是 Bob 的朋友！”，并指望看到Bob 的“protected”（受到保护的）、友好的以及“private”（私有）的成 员。为获得对一个访问权限</p><p>对于任何关系，最重要的一点都是规定好所有方面都必须遵守的界限或规则。创建一个库时，相当于建立了 同那个库的用户（即“客户程序员”）的一种关系——那些用户属于另外的程序员，可能用我们的库自行构 建一个应用程序，或者用我们的库构建一个更大的库。</p><p>如果不制订规则，客户程序员就可以随心所欲地操作一个类的所有成员，无论我们本来愿不愿意其中的一些 成员被直接操作。所有东西都在别人面前都暴露无遗。</p><p>本章讲述了如何构建类，从而制作出理想的库。首先，我们讲述如何将一组类封装到一个库里。其次，我们 讲述类如何控制对自己成员的访问。</p><p>一般情况下，一个 C 程序项目会在 50K 到100K 行代码之间的某个地方开始中断。这是由于 C 仅有一个“命名 空间”，所以名字会开始互相抵触，从而造成额外的管理开销。而在 Java 中，package关键字、包命名方案 以及import关键字为我们提供对名字的完全控制，所以命名冲突的问题可以很轻易地得到避免。</p><p>有两方面的原因要求我们控制对成员的访问。第一个是防止用户接触那些他们不应碰的工具。对于数据类型 的内部机制，那些工具是必需的。但它们并不属于用户接口的一部分，用户不必用它来解决自己的特定问 题。所以将方法和字段变成“私有”（private）后，可极大方便用户。因为他们能轻易看出哪些对于自己来 说是最重要的，以及哪些是自己需要忽略的。这样便简化了用户对一个类的理解。</p><p>进行访问控制的第二个、也是最重要的一个原因是：允许库设计者改变类的内部工作机制，同时不必担心它 会对客户程序员产生什么影响。最开始的时候，可用一种方法构建一个类，后来发现需要重新构建代码，以 便达到更快的速度。如接口和实施细节早已进行了明确的分隔与保护，就可以轻松地达到自己的目的，不要 求用户改写他们的代码。</p><p>利用 Java 中的访问指示符，可有效控制类的创建者。那个类的用户可确切知道哪些是自己能够使用的，哪些 则是可以忽略的。但更重要的一点是，它可确保没有任何用户能依赖一个类的基础实施机制的任何部分。作 为一个类的创建者，我们可自由修改基础的实施细节，这一改变不会对客户程序员产生任何影响，因为他们 不能访问类的那一部分。</p><p>有能力改变基础的实施细节后，除了能在以后改进自己的设置之外，也同时拥有了“犯错误”的自由。无论 当初计划与设计时有多么仔细，仍然有可能出现一些失误。由于知道自己能相当安全地犯下这种错误，所以 可以放心大胆地进行更多、更自由的试验。这对自己编程水平的提高是很有帮助的，使整个项目最终能更 快、更好地完成。</p><p>一个类的公共接口是所有用户都能看见的，所以在进行分析与设计的时候，这是应尽量保证其准确性的最重 要的一个部分。但也不必过于紧张，少许的误差仍然是允许的。若最初设计的接口存在少许问题，可考虑添 加更多的方法，只要保证不删除客户程序员已在他们的代码里使用的东西。</p>',17),o=[r];function c(n,_,s,d,l,v){return e(),p("div",null,o)}const k=a(i,[["render",c]]);export{m as __pageData,k as default};
