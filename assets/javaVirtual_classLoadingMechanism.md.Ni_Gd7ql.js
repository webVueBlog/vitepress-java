import{_ as a,c as e,o as s,a8 as t}from"./chunks/framework.DDO5B0CJ.js";const i="/vitepress-java/assets/img_19.BcnD4duq.png",l="/vitepress-java/assets/img_20.DheNzjGJ.png",n="/vitepress-java/assets/img_21.BUYlV9A6.png",p="/vitepress-java/assets/img_22.C_fhmv10.png",o="/vitepress-java/assets/img_23.CPZCda0T.png",r="/vitepress-java/assets/img_24.BhTqr258.png",c="/vitepress-java/assets/img_25.D3BbxgVe.png",d="/vitepress-java/assets/img_26.CLDlJ04w.png",h="/vitepress-java/assets/img_27.DeFsF3B1.png",g="/vitepress-java/assets/img_28.Bv3lY1u5.png",u="/vitepress-java/assets/img_29.CsChJ6-P.png",y=JSON.parse('{"title":"四、类加载机制","description":"","frontmatter":{},"headers":[],"relativePath":"javaVirtual/classLoadingMechanism.md","filePath":"javaVirtual/classLoadingMechanism.md"}'),m={name:"javaVirtual/classLoadingMechanism.md"},_=t('<h1 id="四、类加载机制" tabindex="-1">四、类加载机制 <a class="header-anchor" href="#四、类加载机制" aria-label="Permalink to &quot;四、类加载机制&quot;">​</a></h1><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次 性加载，那么会占用很多的内存。</p><blockquote><p>类的生命周期</p></blockquote><p><img src="'+i+'" alt="img_19.png" loading="lazy"></p><p>包括以下 7 个阶段：</p><ul><li>加载（Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><blockquote><p>类加载过程</p></blockquote><p>包含了加载、验证、准备、解析和初始化这 5 个阶段</p><h2 id="_1-加载" tabindex="-1">1. 加载 <a class="header-anchor" href="#_1-加载" aria-label="Permalink to &quot;1. 加载&quot;">​</a></h2><p>加载是类加载的一个阶段，注意不要混淆。</p><p>加载过程完成以下三件事：</p><ul><li>通过类的完全限定名称获取定义该类的二进制字节流。</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入 口。</li></ul><p>其中二进制字节流可以从以下方式中获取：</p><ul><li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li><li>从网络中获取，最典型的应用是 Applet。</li><li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用</li><li>ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li></ul><h2 id="_2-验证" tabindex="-1">2. 验证 <a class="header-anchor" href="#_2-验证" aria-label="Permalink to &quot;2. 验证&quot;">​</a></h2><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机 自身的安全。</p><h2 id="_3-准备" tabindex="-1">3. 准备 <a class="header-anchor" href="#_3-准备" aria-label="Permalink to &quot;3. 准备&quot;">​</a></h2><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是 方法区的内存。</p><p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。 应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并 且类加载只进行一次，实例化可以进行多次。</p><p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public static int value = 123;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public static final int value = 123;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="_4-解析" tabindex="-1">4. 解析 <a class="header-anchor" href="#_4-解析" aria-label="Permalink to &quot;4. 解析&quot;">​</a></h2><p>将常量池的符号引用替换为直接引用的过程。</p><p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动 态绑定。</p><h2 id="_5-初始化" tabindex="-1">5. 初始化 <a class="header-anchor" href="#_5-初始化" aria-label="Permalink to &quot;5. 初始化&quot;">​</a></h2><p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类 构造器 <code>&lt;clinit&gt;()</code> 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始 值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资 源</p><p><code>&lt;clinit&gt;()</code> 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合 并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静 态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能 访问。例如以下代码：</p><p><img src="'+l+'" alt="img_20.png" loading="lazy"></p><p>由于父类的 <code>&lt;clinit&gt;() </code>方法先执行，也就意味着父类中定义的静态语句块的执行要优 先于子类。例如以下代码：</p><p><img src="'+n+'" alt="img_21.png" loading="lazy"></p><p><img src="'+p+`" alt="img_22.png" loading="lazy"></p><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一 样都会生成 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，执行接口的 <code>&lt;clinit&gt;()</code> 方法不需要 先执行父接口的 <code>&lt;clinit&gt;()</code> 方法。只有当父接口中定义的变量使用时，父接口才会初 始化。另外，接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法。</p><p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确的加锁和同步，如果多 个线程同时初始化一个类，只会有一个线程执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其它线程 都会阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。如果在一个类的 <code>&lt;clinit&gt;()</code> 方 法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p><h2 id="类初始化时机" tabindex="-1">类初始化时机 <a class="header-anchor" href="#类初始化时机" aria-label="Permalink to &quot;类初始化时机&quot;">​</a></h2><h3 id="_1-主动引用" tabindex="-1">1. 主动引用 <a class="header-anchor" href="#_1-主动引用" aria-label="Permalink to &quot;1. 主动引用&quot;">​</a></h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种 情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p><p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进 行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已 在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方 法的时候。</p><p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始 化，则需要先触发其初始化。</p><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其 父类的初始化。</p><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个 类），虚拟机会先初始化这个主类；</p><p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例 最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄， 并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p><h3 id="_2-被动引用" tabindex="-1">2. 被动引用 <a class="header-anchor" href="#_2-被动引用" aria-label="Permalink to &quot;2. 被动引用&quot;">​</a></h3><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式 都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><p>通过子类引用父类的静态字段，不会导致子类初始化。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>System.out.println(SubClass.value); // value 字段在 SuperClass 中</span></span>
<span class="line"><span>定义</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始 化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了 数组的属性和方法。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>SuperClass[] sca = new SuperClass[10];</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的 类，因此不会触发定义常量的类的初始化。</p><p>System.out.println(ConstClass.HELLOWORLD);</p><h2 id="类与类加载器" tabindex="-1">类与类加载器 <a class="header-anchor" href="#类与类加载器" aria-label="Permalink to &quot;类与类加载器&quot;">​</a></h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个 类加载器都拥有一个独立的类名称空间。</p><p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、 isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判 定结果为 true。</p><h2 id="类加载器分类" tabindex="-1">类加载器分类 <a class="header-anchor" href="#类加载器分类" aria-label="Permalink to &quot;类加载器分类&quot;">​</a></h2><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p><p>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部 分；</p><p>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</p><p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些</p><p>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <code>&lt; JRE_HOME &gt;</code> <code>\\lib</code> 目录中的，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中的， 并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动 类加载器，直接使用 null 代替即可</p><p>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <code>&lt; JAVA_HOME &gt;</code> <code>/lib/ext</code> 或者被 java.ext.dir 系统变量所指定路径中的所有类库加 载到内存中，开发者可以直接使用扩展类加载器。</p><p>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器 是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类 加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接 使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下 这个就是程序中默认的类加载器。</p><h2 id="双亲委派模型" tabindex="-1">双亲委派模型 <a class="header-anchor" href="#双亲委派模型" aria-label="Permalink to &quot;双亲委派模型&quot;">​</a></h2><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义 的类加载器。</p><p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父 类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承 关系（Inheritance）。</p><p><img src="`+o+'" alt="img_23.png" loading="lazy"></p><h3 id="_1-工作过程" tabindex="-1">1. 工作过程 <a class="header-anchor" href="#_1-工作过程" aria-label="Permalink to &quot;1. 工作过程&quot;">​</a></h3><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才 尝试自己加载</p><h3 id="_2-好处" tabindex="-1">2. 好处 <a class="header-anchor" href="#_2-好处" aria-label="Permalink to &quot;2. 好处&quot;">​</a></h3><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础 类得到统一。</p><p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是 启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p><h3 id="_3-实现" tabindex="-1">3. 实现 <a class="header-anchor" href="#_3-实现" aria-label="Permalink to &quot;3. 实现&quot;">​</a></h3><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如 下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载 失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p><p><img src="'+r+'" alt="img_24.png" loading="lazy"></p><p><img src="'+c+'" alt="img_25.png" loading="lazy"></p><p><img src="'+d+'" alt="img_26.png" loading="lazy"></p><p><img src="'+h+'" alt="img_27.png" loading="lazy"></p><h2 id="自定义类加载器实现" tabindex="-1">自定义类加载器实现 <a class="header-anchor" href="#自定义类加载器实现" aria-label="Permalink to &quot;自定义类加载器实现&quot;">​</a></h2><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上 查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p><p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一 般不去重写它，但是需要重写 findClass() 方法。</p><p><img src="'+g+'" alt="img_28.png" loading="lazy"></p><p><img src="'+u+'" alt="img_29.png" loading="lazy"></p>',82),b=[_];function v(C,j,q,k,f,P){return s(),e("div",null,b)}const L=a(m,[["render",v]]);export{y as __pageData,L as default};
