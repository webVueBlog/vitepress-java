import{_ as a,c as e,o as r,a8 as l}from"./chunks/framework.DDO5B0CJ.js";const o="/vitepress-java/assets/img_141.C93a0VFU.png",t="/vitepress-java/assets/img_142.BIVaYgHL.png",k=JSON.parse('{"title":"8.6-Kafka的HighWatermark的作用你知道多少","description":"","frontmatter":{},"headers":[],"relativePath":"AKafka/38.md","filePath":"AKafka/38.md"}'),i={name:"AKafka/38.md"},s=l('<h1 id="_8-6-kafka的highwatermark的作用你知道多少" tabindex="-1">8.6-Kafka的HighWatermark的作用你知道多少 <a class="header-anchor" href="#_8-6-kafka的highwatermark的作用你知道多少" aria-label="Permalink to &quot;8.6-Kafka的HighWatermark的作用你知道多少&quot;">​</a></h1><p><img src="'+o+'" alt="img_141.png" loading="lazy"></p><p>Kafka的HW（High Watermark）是消费者能够读取到的最大的offset，HW之前的消息是可读的， HW之后的消息是未同步的，HW是Kafka中非常重要的一个概念，本文将详细介绍HW的作用。</p><p>Follower故障</p><ul><li>Follower发送故障后会被临时踢出ISR（动态变化），待该follower恢复后，follower会读取本地的磁盘记录的上次的HW，并将该 log文件高于HW的部分截取掉，从HW开始向leader进行同步，等该follower的leo大于等于该Partition的Hw，即follower追上leader后，就可以重新加入ISR</li></ul><p>Leader故障</p><ul><li>Leader发生故障后，会从ISR中选出一个新的leader，</li><li>之后，为保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于HW的部分截掉，然后从新的leader同步数据。</li></ul><h2 id="leader故障" tabindex="-1">Leader故障 <a class="header-anchor" href="#leader故障" aria-label="Permalink to &quot;Leader故障&quot;">​</a></h2><p>Leader发生故障后，会从ISR中选出一个新的leader，为了保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于hw的部分截掉（新leader自己不会 截掉，其他的follower会截掉），然后从新的leader同步数据。</p><p><img src="'+t+'" alt="img_142.png" loading="lazy"></p>',10),_=[s];function d(n,p,f,c,h,m){return r(),e("div",null,_)}const H=a(i,[["render",d]]);export{k as __pageData,H as default};
