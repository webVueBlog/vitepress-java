import{_ as a,c as e,o as s,a8 as n}from"./chunks/framework.DDO5B0CJ.js";const t="/vitepress-java/assets/img_50.CsHzq-QR.png",i="/vitepress-java/assets/img_51.DpFhJXis.png",p="/vitepress-java/assets/img_52.xKcnmML_.png",r="/vitepress-java/assets/img_53.DupbgUFl.png",o="/vitepress-java/assets/img_54.DR6gamnu.png",l="/vitepress-java/assets/img_55.CPMICY8l.png",c="/vitepress-java/assets/img_56.C4tMcWh4.png",u="/vitepress-java/assets/img_57.ChxiiWjn.png",d="/vitepress-java/assets/img_58.dzktEIeW.png",g="/vitepress-java/assets/img_59.B_AE-hZ0.png",m="/vitepress-java/assets/img_60.DaShhh-m.png",P=JSON.parse('{"title":"J.U.C - 其它组件","description":"","frontmatter":{},"headers":[],"relativePath":"javaConcurrency/juc-other.md","filePath":"javaConcurrency/juc-other.md"}'),h={name:"javaConcurrency/juc-other.md"},_=n('<h1 id="j-u-c-其它组件" tabindex="-1">J.U.C - 其它组件 <a class="header-anchor" href="#j-u-c-其它组件" aria-label="Permalink to &quot;J.U.C - 其它组件&quot;">​</a></h1><h2 id="futuretask" tabindex="-1">FutureTask <a class="header-anchor" href="#futuretask" aria-label="Permalink to &quot;FutureTask&quot;">​</a></h2><p>在介绍 <code>Callable</code> 时我们知道它可以有返回值，返回值通过 <code>Future&lt;V&gt;</code> 进行封装。 <code>FutureTask</code> 实现了 <code>RunnableFuture</code> 接口，该接口继承自 Runnable 和 <code>Future&lt;V&gt;</code> 接 口，这使得 <code>FutureTask</code> 既可以当做一个任务执行，也可以有返回值。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>FutureTask</code> 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用一个 <code>FutureTask</code> 来包装该任务 ，用另一个线程来执行这个 <code>FutureTask</code>。这样就能充分利用多核 CPU 的优势，让每个 CPU 核都执行一个线程，从而提升程序的执行效率。</p><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执 行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务 之后再去获取结果。</p><p><img src="'+t+'" alt="img_50.png" loading="lazy"></p><p><img src="'+i+'" alt="img_51.png" loading="lazy"></p><p><img src="'+p+'" alt="img_52.png" loading="lazy"></p><p><img src="'+r+'" alt="img_53.png" loading="lazy"></p><h2 id="blockingqueue" tabindex="-1">BlockingQueue <a class="header-anchor" href="#blockingqueue" aria-label="Permalink to &quot;BlockingQueue&quot;">​</a></h2><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p><p>FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</p><p>优先级队列 ：PriorityBlockingQueue</p><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内 容；如果队列为满 put() 将阻塞，直到队列有空闲位置</p><blockquote><p>使用 BlockingQueue 实现生产者消费者问题</p></blockquote><p><img src="'+o+'" alt="img_54.png" loading="lazy"></p><p><img src="'+l+'" alt="img_55.png" loading="lazy"></p><p><img src="'+c+`" alt="img_56.png" loading="lazy"></p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>produce..produce..consume..consume..produce..consume..produce..co</span></span>
<span class="line"><span>nsume..produce..consume..</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="forkjoin" tabindex="-1">ForkJoin <a class="header-anchor" href="#forkjoin" aria-label="Permalink to &quot;ForkJoin&quot;">​</a></h2><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小 任务并行计算。</p><p><img src="`+u+'" alt="img_57.png" loading="lazy"></p><p><img src="'+d+'" alt="img_58.png" loading="lazy"></p><p><img src="'+g+'" alt="img_59.png" loading="lazy"></p><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public class ForkJoinPool extends AbstractExecutorService</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双 端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端 队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发 生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会 发生竞争。</p><p><img src="'+m+'" alt="img_60.png" loading="lazy"></p>',30),b=[_];function v(k,C,F,j,y,T){return s(),e("div",null,b)}const q=a(h,[["render",v]]);export{P as __pageData,q as default};
