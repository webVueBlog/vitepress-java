import{_ as a,c as s,o as t,a8 as e}from"./chunks/framework.DDO5B0CJ.js";const p="/vitepress-java/assets/img_71.CDU6PvOJ.png",i="/vitepress-java/assets/img_72.CJC29e-b.png",_="/vitepress-java/assets/img_73.BHNjxnwo.png",o="/vitepress-java/assets/img_74.DUiMiq_m.png",n="/vitepress-java/assets/img_75.BwK0wXBt.png",r="/vitepress-java/assets/img_76.CWXpPphD.png",g="/vitepress-java/assets/img_77.DmxFSsSV.png",f=JSON.parse('{"title":"第 13 章 分 组 数 据","description":"","frontmatter":{},"headers":[],"relativePath":"MySQL/13.md","filePath":"MySQL/13.md"}'),m={name:"MySQL/13.md"},l=e('<h1 id="第-13-章-分-组-数-据" tabindex="-1">第 13 章 分 组 数 据 <a class="header-anchor" href="#第-13-章-分-组-数-据" aria-label="Permalink to &quot;第 13 章 分 组 数 据&quot;">​</a></h1><p>分别是GROUP BY子句和HAVING子句。</p><p>供应商1003提供的产品数目：</p><p><img src="'+p+'" alt="img_71.png" loading="lazy"></p><p>分组是在SELECT语句的GROUP BY子句中建立的。</p><p><img src="'+i+'" alt="img_72.png" loading="lazy"></p><p><img src="'+_+'" alt="img_73.png" loading="lazy"></p><h2 id="过滤分组" tabindex="-1">过滤分组 <a class="header-anchor" href="#过滤分组" aria-label="Permalink to &quot;过滤分组&quot;">​</a></h2><p>所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是 WHERE过滤行，而HAVING过滤分组。</p><p><img src="'+o+'" alt="img_74.png" loading="lazy"></p><p><img src="'+n+'" alt="img_75.png" loading="lazy"></p><blockquote><p>不要忘记ORDER BY 一般在使用GROUP BY子句时，应该也给 出ORDER BY子句。这是保证数据正确排序的唯一方法。千万 不要仅依赖GROUP BY排序数据。</p></blockquote><p><img src="'+r+'" alt="img_76.png" loading="lazy"></p><p><img src="'+g+'" alt="img_77.png" loading="lazy"></p><p>GROUP BY子句用来按订单号（order_num列） 分组数据，以便SUM(*)函数能够返回总计订单价格。HAVING子 句过滤数据，使得只返回总计订单价格大于等于50的订单</p>',15),c=[l];function d(h,v,P,u,B,R){return t(),s("div",null,c)}const y=a(m,[["render",d]]);export{f as __pageData,y as default};
