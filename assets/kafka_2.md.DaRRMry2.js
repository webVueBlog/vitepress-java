import{_ as p,c as e,o as t,a8 as a}from"./chunks/framework.DDO5B0CJ.js";const s="/vitepress-java/assets/img_171.Cf4QDyZM.png",i="/vitepress-java/assets/img_172.CNvmCCnF.png",o="/vitepress-java/assets/img_173.CcO8YJdi.png",r="/vitepress-java/assets/img_174.CbdWSmDV.png",n="/vitepress-java/assets/img_175.BW2NT8rx.png",c="/vitepress-java/assets/img_176.Dz9RrokJ.png",_="/vitepress-java/assets/img_177.CSirG3g1.png",l="/vitepress-java/assets/img_178.CqMcJ64Y.png",m="/vitepress-java/assets/img_179.Iv6AWPsM.png",g="/vitepress-java/assets/img_180.Cd1-3e5Z.png",u=JSON.parse('{"title":"Kafka消费者在内存充足时没有背压，如何解决消费延迟大的问题","description":"","frontmatter":{},"headers":[],"relativePath":"kafka/2.md","filePath":"kafka/2.md"}'),k={name:"kafka/2.md"},d=a('<h1 id="kafka消费者在内存充足时没有背压-如何解决消费延迟大的问题" tabindex="-1">Kafka消费者在内存充足时没有背压，如何解决消费延迟大的问题 <a class="header-anchor" href="#kafka消费者在内存充足时没有背压-如何解决消费延迟大的问题" aria-label="Permalink to &quot;Kafka消费者在内存充足时没有背压，如何解决消费延迟大的问题&quot;">​</a></h1><p>问题：</p><p>那就是生产着发送数据正常，消费者客户端在消费数据的时候既没有产生背压，同时内存也是充足的。</p><p>但是消费延迟很大，导致消费速度跟不上生产速度。（但产生的消费延迟越来越大），比如在我们这个kafka集群一共有3个Broker节点。</p><p>Topic1一共有5个分区，分别是P0，P1，P2，P3，P4。</p><p><img src="'+s+'" alt="img_171.png" loading="lazy"></p><p>创建了包含两个消费者的消费者组。</p><p>消费者1同时消费P0，P1，和P4分区的数据，消费者2消费P2，P3分区的数据。</p><p>看到消费延迟，大家的第一想法就是增加消费者数量和分区的数量。让消费者数量增加到和Partition数量一样(多)， （这样每个消费者就可以仅仅消费一个分区的数据，可以达到消费分区的最大化） （但有时候这样做并不能显著的提升消费能力，主要原因就是，现在的消费者组中的消费并没有产生背压，同时内存也是充足的， 只是增加Partition和消费者的数量不能解决问题，如果遇到这种现象改怎么办呢？） 这样就可以保证每个分区都有消费者消费，消费延迟自然就下降了。</p><p>但是这样做的成本太高了，因为增加消费者数量和分区的数量，需要重新分配分区，</p><blockquote><p>要了解消费者背后的执行原理</p></blockquote><p>调节哪些参数，该如何优化消费者消费数据的吞吐量</p><p>消费者消费数据的原理</p><p>消费者在调用poll()方法到远端的Broker节点拉取数据时，优先从nextInLineFetch中获取数据，这个nextInLineFetch就是数据接收缓冲区， 如果数据接收缓冲区中没有待消费的数据，就调用sendFetches()方法，到Broker端拉取数据。</p><p>kafka是向相应的Broker节点发送拉取数据的网络请求。</p><p>我们都知道网络请求相对于内存请求是比较慢的。因此这些拉取数据的网络请求，是由Broker端异步执行的。异步执行拉取数据请求，就必须通过future监听数据是否 已经准备好。当数据准备好之后，会将数据放到数据接收缓存completedFetches中，这是因为IO请求比较耗时，所以尽量一次批量拉取更多的数据放到缓存中。 这样就可以降低发起网络的IO次数，进而提升消费能力，现在缓冲区completedFetches中已经有数据了。</p><p><img src="'+i+'" alt="img_172.png" loading="lazy"></p><p>就会把completedFetches中队头的数据解析到nextInLineFetch中，</p><p><img src="'+o+'" alt="img_173.png" loading="lazy"></p><p><img src="'+r+'" alt="img_174.png" loading="lazy"></p><p>Partition Records解析成消费者可以消费的数据格式。然后清除completedFetches中队头的元素。 随后如果有消费者调用poll()方法，就会从nextInLineFetch中获取数据，</p><p><img src="'+n+'" alt="img_175.png" loading="lazy"></p><p>消费者客户端每次获取的数据量是由参数max.poll.records控制的，默认值是500 相当于每次从nextInLineFetch中获取500条数据并返回给消费者。</p><p>当消费者消费完这500条数据之后，就会再次调用poll()方法，从nextInLineFetch中获取数据。（500条数据）</p><p>当消费者把nextInLineFetch缓存的数据都消费完之后，相当于在调用poll()方法时，nextInLineFetch已经没有待消费的数据了。</p><p>这个时候，就会把completedFetch的新的队头元素解析解析成nextInLineFetch。</p><p><img src="'+c+'" alt="img_176.png" loading="lazy"></p><p>然后才会删除completedFetch的队头元素。</p><p><img src="'+_+'" alt="img_177.png" loading="lazy"></p><p>了解了数据消费原理之后，我们就可以通过优化调整这几个参数。去提升消费数据的能力</p><p><img src="'+l+'" alt="img_178.png" loading="lazy"></p><p>参数fetch.min.bytes，默认值是1字节，表示每次从Broker节点上拉取的最小数据量。</p><p>如果Broker节点上没有数据，那么每次拉取的数据量至少是1字节。(如果Broker上未消费的数据不足1字节时，会默认最多等待500ms， 消费者客户端会等待，直到Broker节点上有了1字节的数据，才会拉取数据。)</p><p>最多等待的时间由参数fetch.max.wait.ms控制，默认值是500ms。</p><p>每次最小获取1字节的数据未免太小了，太小了会降低拉取数据的吞吐量。可以适当的将该参数增加到16KB或者32KB. 参数fetch.max.bytes表示每次poll操作。从Broker端最多拉取到数据量，默认值是50MB，如果我们客户端的资源充足，建议适当增大这个参数值。 可以增加到200MB以上。</p><p>参数max.partition.fetch.bytes的默认值是1MB.表示每次poll返回的，每个Broker节点上每个分区的最大字节数。</p><p><img src="'+m+'" alt="img_179.png" loading="lazy"></p><p>只有Topic-1的一个分区，那么每次从Broker-102上最多能拉取到的数据也就是1MB。</p><p>数据量未免太小了。有时候刚消费完1MB，就得再从Broker-102上拉取1MB的数据。（就得再经过一次网络IO拉取下一批数据）</p><blockquote><p>这个可能是造成消费延迟的主要原因</p></blockquote><p>因此，大家可以根据自己的Topic的实际分区数，去合理的设置每个分区每次拉取数据的大小。</p><p>通常可以将每个分区每次拉取数据的大小设置成10MB以上。但有的时候只是提高每个分区每次最大拉取到的数据也是不够的。</p><p>因为每个Broker最多返回的最大字节数由参数fetch.max.bytes控制，默认值是50MB。</p><p>有时候也可以适当的提升这个参数的默认值。比如增加到200MB，这样就能在本地尽量缓存更多的数据。去提升消费者消费数据的能力，降低消费延迟。</p><p>修改以下参数，主要是适用于内存充足，但消费能力不足的场景。</p><p>但有时候需要注意的是，kafka的系统管理员为了让kafka的服务端没有太大的压力，通常把这个参数值设置成静态的。也就是说，在消费者客户端根本就不能修改这个参数， 修改了也不生效。所谓的设置成静态，就是在config/server.properties中进行了配置。</p><p><img src="'+g+'" alt="img_180.png" loading="lazy"></p><p>遇到消费延迟，可以通过设置这些参数，来提升消费能力的。</p>',48),h=[d];function f(B,v,x,P,F,y){return t(),e("div",null,h)}const M=p(k,[["render",f]]);export{u as __pageData,M as default};
