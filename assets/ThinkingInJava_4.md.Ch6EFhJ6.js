import{_ as a,c as e,o as i,a8 as t}from"./chunks/framework.DDO5B0CJ.js";const u=JSON.parse('{"title":"第 4 章 初始化和清除","description":"","frontmatter":{},"headers":[],"relativePath":"ThinkingInJava/4.md","filePath":"ThinkingInJava/4.md"}'),n={name:"ThinkingInJava/4.md"},l=t('<h1 id="第-4-章-初始化和清除" tabindex="-1">第 4 章 初始化和清除 <a class="header-anchor" href="#第-4-章-初始化和清除" aria-label="Permalink to &quot;第 4 章 初始化和清除&quot;">​</a></h1><h2 id="_4-1-用构建器自动初始化" tabindex="-1">4.1 用构建器自动初始化 <a class="header-anchor" href="#_4-1-用构建器自动初始化" aria-label="Permalink to &quot;4.1 用构建器自动初始化&quot;">​</a></h2><p>构建器属于一种较特殊的方法类型，因为它没有返回值。这与 void返回值存在着明显的区别。对于void返 回值，尽管方法本身不会自动返回什么，但仍然可以让它返回另一些东西。构建器则不同，它不仅什么也不 会自动返回，而且根本不能有任何选择。若存在一个返回值，而且假设我们可以自行选择返回内容，那么编 译器多少要知道如何对那个返回值作什么样的处理。</p><h2 id="_4-2-方法过载" tabindex="-1">4.2 方法过载 <a class="header-anchor" href="#_4-2-方法过载" aria-label="Permalink to &quot;4.2 方法过载&quot;">​</a></h2><p>方法过载允许我们为两者使用相同的名字。</p><h3 id="_4-2-1-区分过载方法" tabindex="-1">4.2.1 区分过载方法 <a class="header-anchor" href="#_4-2-1-区分过载方法" aria-label="Permalink to &quot;4.2.1 区分过载方法&quot;">​</a></h3><p>若方法有同样的名字，Java 怎样知道我们指的哪一个方法呢？这里有一个简单的规则：每个过载的方法都必 须采取独一无二的自变量类型列表。</p><h2 id="_4-3-清除-收尾和垃圾收集" tabindex="-1">4.3 清除：收尾和垃圾收集 <a class="header-anchor" href="#_4-3-清除-收尾和垃圾收集" aria-label="Permalink to &quot;4.3 清除：收尾和垃圾收集&quot;">​</a></h2><p>程序员都知道“初始化”的重要性，但通常忘记清除的重要性。毕竟，谁需要来清除一个int呢？但是对于 库来说，用完后简单地“释放”一个对象并非总是安全的。当然，Java 可用垃圾收集器回收由不再使用的对 象占据的内存。现在考虑一种非常特殊且不多见的情况。假定我们的对象分配了一个“特殊”内存区域，没 有使用 new 。垃圾收集器只知道释放那些由new 分配的内存，所以不知道如何释放对象的“特殊”内存。为 解决这个问题，Java 提供了一个名为finalize()的方法，可为我们的类定义它。在理想情况下，它的工作原 理应该是这样的：一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用 finalize()，而且只有在下 一次垃圾收集过程中，才会真正回收对象的内存。所以如果使用finalize()，就可以在垃圾收集期间进行一 些重要的清除或清扫工作。</p><p>垃圾收集并不等于“破坏”！</p><p>若能时刻牢记这一点，踩到陷阱的可能性就会大大减少。它意味着在我们不再需要一个对象之前，有些行动 是必须采取的，而且必须由自己来采取这些行动。Java 并未提供“破坏器”或者类似的概念，所以必须创建 一个原始的方法，用它来进行这种清除。例如，假设在对象创建过程中，它会将自己描绘到屏幕上。如果不 从屏幕明确删除它的图像，那么它可能永远都不会被清除。若在finalize()里置入某种删除机制，那么假设 对象被当作垃圾收掉了，图像首先会将自身从屏幕上移去。但若未被收掉，图像就会保留下来。所以要记住 的第二个重点是：</p><p>我们的对象可能不会当作垃圾被收掉！</p><p>有时可能发现一个对象的存储空间永远都不会释放，因为自己的程序永远都接近于用光空间的临界点。若程 序执行结束，而且垃圾收集器一直都没有释放我们创建的任何对象的存储空间，则随着程序的退出，那些资 源会返回给操作系统。这是一件好事情，因为垃圾收集本身也要消耗一些开销。如永远都不用它，那么永远 也不用支出这部分开销</p><h3 id="_4-3-1-finalize-用途何在" tabindex="-1">4.3.1 finalize() 用途何在 <a class="header-anchor" href="#_4-3-1-finalize-用途何在" aria-label="Permalink to &quot;4.3.1 finalize() 用途何在&quot;">​</a></h3><p>此时，大家可能已相信了自己应该将finalize()作为一种常规用途的清除方法使用。它有什么好处呢？ 要记住的第三个重点是：</p><p>垃圾收集只跟内存有关！</p><p>也就是说，垃圾收集器存在的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾收集有关的任何活 动来说，其中最值得注意的是 finalize()方法，它们也必须同内存以及它的回收有关。</p><p>但这是否意味着假如对象包含了其他对象，finalize()就应该明确释放那些对象呢？答案是否定的——垃圾 收集器会负责释放所有对象占据的内存，无论这些对象是如何创建的。它将对finalize()的需求限制到特殊 的情况。在这种情况下，我们的对象可采用与创建对象时不同的方法分配一些存储空间。但大家或许会注意 到，Java 中的所有东西都是对象，所以这到底是怎么一回事呢？</p><h2 id="_4-4-成员初始化" tabindex="-1">4.4 成员初始化 <a class="header-anchor" href="#_4-4-成员初始化" aria-label="Permalink to &quot;4.4 成员初始化&quot;">​</a></h2><p>Java 尽自己的全力保证所有变量都能在使用前得到正确的初始化。若被定义成相对于一个方法的“局部”变 量，这一保证就通过编译期的出错提示表现出来。</p><ol><li>初始化顺序</li></ol><p>在一个类里，初始化的顺序是由变量在类内的定义顺序决定的。</p><ol start="2"><li>静态数据的初始化</li></ol><h2 id="_4-5-数组初始化" tabindex="-1">4.5 数组初始化 <a class="header-anchor" href="#_4-5-数组初始化" aria-label="Permalink to &quot;4.5 数组初始化&quot;">​</a></h2><p>作为初始化的一种具体操作形式，构建器应使大家明确感受到在语言中进行初始化的重要性。与 C++ 的程序 设计一样，判断一个程序效率如何，关键是看是否由于变量的初始化不正确而造成了严重的编程错误（臭 虫）。这些形式的错误很难发现，而且类似的问题也适用于不正确的清除或收尾工作。由于构建器使我们能 保证正确的初始化和清除（若没有正确的构建器调用，编译器不允许对象创建），所以能获得完全的控制权 和安全性。</p><p>在C++ 中，与“构建”相反的“破坏”（Destruction）工作也是相当重要的，因为用new 创建的对象必须明 确地清除。在Java 中，垃圾收集器会自动为所有对象释放内存，所以 Java 中等价的清除方法并不是经常都 需要用到的。如果不需要类似于构建器的行为，Java 的垃圾收集器可以极大简化编程工作，而且在内存的管 理过程中增加更大的安全性。有些垃圾收集器甚至能清除其他资源，比如图形和文件句柄等。然而，垃圾收 集器确实也增加了运行期的开销。但这种开销到底造成了多大的影响却是很难看出的，因为到目前为止， Java 解释器的总体运行速度仍然是比较慢的。随着这一情况的改观，我们应该能判断出垃圾收集器的开销是 否使Java 不适合做一些特定的工作（其中一个问题是垃圾收集器不可预测的性质）。</p><p>由于所有对象都肯定能获得正确的构建，所以同这儿讲述的情况相比，构建器实际做的事情还要多得多。特 别地，当我们通过“创作”或“继承”生成新类的时候，对构建的保证仍然有效，而且需要一些附加的语法 来提供对它的支持。</p>',27),o=[l];function r(h,p,_,d,s,c){return i(),e("div",null,o)}const v=a(n,[["render",r]]);export{u as __pageData,v as default};
