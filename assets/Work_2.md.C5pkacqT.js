import{_ as a,c as s,o as n,a8 as e}from"./chunks/framework.DDO5B0CJ.js";const t="/vitepress-java/assets/img_1.Dxc69a3b.png",p="/vitepress-java/assets/img_2.4WAUv88h.png",l="/vitepress-java/assets/img.DfLxWRNO.png",i="/vitepress-java/assets/img_3.BMC6Cx2A.png",k=JSON.parse('{"title":"滚到发布(服务无耦合依赖)，蓝绿发布(服务间强耦合依赖)","description":"","frontmatter":{},"headers":[],"relativePath":"Work/2.md","filePath":"Work/2.md"}'),r={name:"Work/2.md"},d=e('<h1 id="滚到发布-服务无耦合依赖-蓝绿发布-服务间强耦合依赖" tabindex="-1">滚到发布(服务无耦合依赖)，蓝绿发布(服务间强耦合依赖) <a class="header-anchor" href="#滚到发布-服务无耦合依赖-蓝绿发布-服务间强耦合依赖" aria-label="Permalink to &quot;滚到发布(服务无耦合依赖)，蓝绿发布(服务间强耦合依赖)&quot;">​</a></h1><h2 id="_1-滚动发布" tabindex="-1">1. 滚动发布 <a class="header-anchor" href="#_1-滚动发布" aria-label="Permalink to &quot;1. 滚动发布&quot;">​</a></h2><p>滚动发布，即逐步发布新版本，逐步下线旧版本。</p><h2 id="_2-蓝绿发布" tabindex="-1">2. 蓝绿发布 <a class="header-anchor" href="#_2-蓝绿发布" aria-label="Permalink to &quot;2. 蓝绿发布&quot;">​</a></h2><p><img src="'+t+'" alt="img_1.png" loading="lazy"></p><p>蓝绿发布，即同时运行两个版本的服务，通过负载均衡将请求路由到新版本或旧版本。</p><h2 id="_3-金丝雀发布" tabindex="-1">3. 金丝雀发布 <a class="header-anchor" href="#_3-金丝雀发布" aria-label="Permalink to &quot;3. 金丝雀发布&quot;">​</a></h2><p>金丝雀发布，即先发布新版本，然后逐渐将请求路由到新版本。</p><h2 id="_4-灰度发布" tabindex="-1">4. 灰度发布 <a class="header-anchor" href="#_4-灰度发布" aria-label="Permalink to &quot;4. 灰度发布&quot;">​</a></h2><p>灰度发布，即先发布新版本，然后逐渐将新版本与旧版本一起提供服务。灰度发布属于增量发布。</p><p>灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。 通过将新版本的服务与旧版本的服务同时运行，并让用户流量逐步从旧版本切换到新版本，从而实现无痛升级。 （在其上可以进行A/B testing，即让一部分用户继续用产品，一部分用户开始用产品的新版本，如果用户对新版本没有什么反对意见， 那么逐步扩大新版本部署范围，直到全部用户都开始用新版本。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现，调整问题，以保证其影响度。）</p><p><img src="'+p+'" alt="img_2.png" loading="lazy"></p><h2 id="词意" tabindex="-1">词意 <a class="header-anchor" href="#词意" aria-label="Permalink to &quot;词意&quot;">​</a></h2><p>灰环境：在新功能或新版本上线之前，先在灰环境进行测试和验证。其作用是确保新版本在上线之前能够正常运行，并发现可能存在的任何问题。</p><p>绿环境：当前正在为用户提供服务的生产环境，所有用户流量都被导向这个环境，保证服务的正常运行。</p><p>蓝环境：是与绿色环境平行准备的环境，用于部署新版本的应用并进行最后的验证测试。其核心目的是在不影响用户体验的前提下，通过流量切换（流量切蓝/流量切回绿）。 平滑地将新版本应用上线，同时提供快速回滚的能力，以确保服务的连续性和稳定性。</p><p>滚动发布：逐步替换旧版本服务实例为新版本服务实例的策略。在滚动更新过程中，系统会按照预定策略（如一次替换一个或一组实例）逐步关闭旧版本的服务实例，并 启动相应数量的新版本服务实例。</p><p>全量发布：指的是一次性将新版本应用的所有组件全部替换掉旧版本，一次性完成整个系统的升级，系统服务短期中断。</p><p>灰度流量：打灰度标签用户的流量</p><p>全流量：指包含标签和非标签用户流量</p><h2 id="备注说明" tabindex="-1">备注说明 <a class="header-anchor" href="#备注说明" aria-label="Permalink to &quot;备注说明&quot;">​</a></h2><ol><li>灰度环境发布：标签用户流量进入验证</li><li>灰度验证：功能验证最后阶段</li><li>微服务（应用）间依赖耦合度：需要技术评审</li><li>滚动绿环境发布：无需流量切换</li><li>滚动绿环境发布验证：如果出现严重缺陷，立刻将部署内容回滚</li><li>蓝环境发布全量（滚动）发布：从绿环境切流量过来需要逐步过程</li><li>蓝环境验证：如果出现严重缺陷，迅速将流量切回绿环境</li><li>全量绿环境发布：从蓝环境切流量过来需要逐步过程</li><li>全量绿环境发布验证：如果出现严重缺陷，迅速将流量切回蓝环境</li></ol><p><img src="'+l+'" alt="img.png" loading="lazy"></p><p>全量发布: 蓝绿部署，红黑部署</p><ul><li>回滚周期长</li><li>BUG导致服务集群雪崩</li><li>服务可能性差，影响用户体验</li></ul><p>灰度发布（增量发布）</p><ul><li>降低发布影响面，提升用户体验</li><li>可以做到不停机迁移</li><li>回滚速度快</li></ul><p>发布方案对比图</p><table><thead><tr><th>策略</th><th>零停机</th><th>生产流量测试</th><th>针对特定用户</th><th>机器资源成本</th><th>回滚时长</th></tr></thead><tbody><tr><td>全量发布</td><td>否</td><td>否</td><td>否</td><td>低</td><td>慢</td></tr><tr><td>蓝绿发布</td><td>是</td><td>否</td><td>否</td><td>高（双倍）</td><td>快</td></tr><tr><td>金丝雀发布</td><td>是</td><td>是</td><td>是</td><td>中（按需）</td><td>快</td></tr><tr><td>全链路灰度</td><td>是</td><td>是</td><td>是</td><td>中（按需）</td><td>快</td></tr></tbody></table><p>金丝雀发布</p><p>据说以前有个典故，矿工开矿前，会先放一只金丝雀下去，看金丝雀是否能够活下来，用来探测是否有毒气，金丝雀发布也是由此得名。</p><h2 id="配置文件" tabindex="-1">配置文件 <a class="header-anchor" href="#配置文件" aria-label="Permalink to &quot;配置文件&quot;">​</a></h2><p><img src="'+i+`" alt="img_3.png" loading="lazy"></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>local redis = require &quot;resty.redis&quot;</span></span>
<span class="line"><span>local red = redis:new()</span></span>
<span class="line"><span>local ok, err = red:connect(&quot;127.0.0.1&quot;, 6379)</span></span>
<span class="line"><span>if not ok then</span></span>
<span class="line"><span>    ngx.say(&quot;failed to connect: &quot;, err)</span></span>
<span class="line"><span>    return</span></span>
<span class="line"><span>end</span></span>
<span class="line"><span></span></span>
<span class="line"><span>local token = ngx.req.get_headers()[&quot;token&quot;]</span></span>
<span class="line"><span>if token ~= nil then</span></span>
<span class="line"><span>    local userId = red:get(token)</span></span>
<span class="line"><span>    local isCanary, err = red:smismember(&quot;CANARY_USER_IDS&quot;, userId)</span></span>
<span class="line"><span>    if isCanary[1] == 1 then</span></span>
<span class="line"><span>        ngx.exec(&quot;@CanaryServer&quot;)</span></span>
<span class="line"><span>        return</span></span>
<span class="line"><span>    end</span></span>
<span class="line"><span>end</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ngx.exec(&quot;@MainServer&quot;)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div>`,34),o=[d];function c(h,u,b,m,_,g){return n(),s("div",null,o)}const f=a(r,[["render",c]]);export{k as __pageData,f as default};
