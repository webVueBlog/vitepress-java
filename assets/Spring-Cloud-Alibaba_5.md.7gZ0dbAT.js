import{_ as a,c as i,o as s,a8 as t}from"./chunks/framework.DDO5B0CJ.js";const e="/vitepress-java/assets/img_7.BHrEk6c6.png",l="/vitepress-java/assets/img_8.DUs8Xvdr.png",o="/vitepress-java/assets/img_9.C-YY6_GV.png",p="/vitepress-java/assets/img_10.CuDz8vyv.png",r="/vitepress-java/assets/img_11.DvKhg6mo.png",n="/vitepress-java/assets/img_12.DScD0F8V.png",_="/vitepress-java/assets/img_13.iQkOkSNc.png",g="/vitepress-java/assets/img_14.-IrIMSRB.png",c="/vitepress-java/assets/img_15.C2jHdcEe.png",f=JSON.parse('{"title":"05-微服务架构的常见问题和解决思路","description":"","frontmatter":{},"headers":[],"relativePath":"Spring-Cloud-Alibaba/5.md","filePath":"Spring-Cloud-Alibaba/5.md"}'),m={name:"Spring-Cloud-Alibaba/5.md"},d=t('<h1 id="_05-微服务架构的常见问题和解决思路" tabindex="-1">05-微服务架构的常见问题和解决思路 <a class="header-anchor" href="#_05-微服务架构的常见问题和解决思路" aria-label="Permalink to &quot;05-微服务架构的常见问题和解决思路&quot;">​</a></h1><p><img src="'+e+'" alt="img_7.png" loading="lazy"></p><ol><li>服务治理就是进行服务的自动化管理，包括服务的注册、发现、熔断、负载均衡、路由、配置等。（其核心是服务的自动注册与发现）</li><li>服务注册：将服务提供者注册到注册中心，使服务消费者能够找到服务提供者。（服务实例将自身服务信息注册到注册中心，供其他微服务进行调用）</li><li>服务发现：服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。</li><li>服务剔除：服务注册中心将出问题的服务自动剔除到可用列表之外，使其不会被调用到。</li></ol><h3 id="服务调用" tabindex="-1">服务调用 <a class="header-anchor" href="#服务调用" aria-label="Permalink to &quot;服务调用&quot;">​</a></h3><p>在微服务架构中，通常存在多个服务之间的远程调用的需求。目前主流的远程调用技术有基于HTTP的REST风格和基于TCP的RPC远程调用技术。</p><ul><li>REST（Representational State Transfer）：表现层状态转化，它是一种互联网应用程序的API设计理念。 (REST是一种架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。 基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。) REST是一种HTTP调用的格式，更标准，更通用，无论哪种语言都支持HTTP协议。</li><li>RPC（Remote Procedure Call）：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。 RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。 在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 RPC采用客户机/服务器模式。请求程序是一个客户机，而服务提供程序是一个服务器。 RPC是一种进程通信方式。允许像调用本地服务一样调用远程服务。RPC框架的主要目标就是让远程服务调用更简单、透明。RPC框架负责屏蔽底层的传输方式、序列化方式和 通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。</li></ul><p><img src="'+l+'" alt="img_8.png" loading="lazy"></p><h3 id="服务网关" tabindex="-1">服务网关 <a class="header-anchor" href="#服务网关" aria-label="Permalink to &quot;服务网关&quot;">​</a></h3><p>随着微服务的不断增多，不同的微服务一般会有不同的网络地址，因此服务间的请求调用会变得非常麻烦。</p><p>随着微服务的不断增多，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求， 如果让客户端直接与各个微服务通信，会有以下的问题：</p><ol><li>客户端需要知道具体有哪些微服务实例，并且能够维护这些实例的网络地址。</li><li>客户端需要能够处理多个微服务实例的响应结果。</li><li>客户端需要处理多个微服务实例的异常情况。</li></ol><blockquote><p>客户端需要调用不同的url地址，增加难度</p><p>在一定的场景下，存在跨域请求的问题</p><p>每个微服务都需要进行单独的身份认证</p></blockquote><p><img src="'+o+'" alt="img_9.png" loading="lazy"></p><p><img src="'+p+'" alt="img_10.png" loading="lazy"></p><h3 id="服务容错" tabindex="-1">服务容错 <a class="header-anchor" href="#服务容错" aria-label="Permalink to &quot;服务容错&quot;">​</a></h3><p>在微服务当中，一个请求经常会涉及多个服务，如果其中一个服务出现故障，那么整个请求就会失败，进而导致整个系统崩溃。这就是雪崩效应。</p><p><img src="'+r+'" alt="img_11.png" loading="lazy"></p><p><img src="'+n+'" alt="img_12.png" loading="lazy"></p><h2 id="链路追踪" tabindex="-1">链路追踪 <a class="header-anchor" href="#链路追踪" aria-label="Permalink to &quot;链路追踪&quot;">​</a></h2><p><img src="'+_+'" alt="img_13.png" loading="lazy"></p><p><img src="'+g+'" alt="img_14.png" loading="lazy"></p><p><img src="'+c+'" alt="img_15.png" loading="lazy"></p>',22),h=[d];function P(u,v,C,T,b,R){return s(),i("div",null,h)}const k=a(m,[["render",P]]);export{f as __pageData,k as default};
