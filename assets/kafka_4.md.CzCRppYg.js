import{_ as a,c as e,o as s,a8 as p}from"./chunks/framework.DDO5B0CJ.js";const t="/vitepress-java/assets/img_214.DFmRbIHq.png",i="/vitepress-java/assets/img_215.Ba-z8Tn6.png",c="/vitepress-java/assets/img_216.CGnsFxkl.png",o="/vitepress-java/assets/img_217.B2elFJww.png",_="/vitepress-java/assets/img_218.BhUDSqVz.png",P=JSON.parse('{"title":"Kafka为什么快之零拷贝技术（splice() + DMA copy）","description":"","frontmatter":{},"headers":[],"relativePath":"kafka/4.md","filePath":"kafka/4.md"}'),n={name:"kafka/4.md"},l=p('<h1 id="kafka为什么快之零拷贝技术-splice-dma-copy" tabindex="-1">Kafka为什么快之零拷贝技术（splice() + DMA copy） <a class="header-anchor" href="#kafka为什么快之零拷贝技术-splice-dma-copy" aria-label="Permalink to &quot;Kafka为什么快之零拷贝技术（splice() + DMA copy）&quot;">​</a></h1><p><img src="'+t+'" alt="img_214.png" loading="lazy"></p><p>首先，用户进程通过splice()函数，向linux内核发起一次调用，（发起splice()系统调用用户态切换内核态）</p><p><img src="'+i+'" alt="img_215.png" loading="lazy"></p><p>然后，内核态通过DMA copy，将数据从网卡拷贝到内核态的缓冲区，然后通过DMA copy，将数据从内核态的缓冲区拷贝到用户态的缓冲区。</p><p>CPU利用DMA控制器，向硬盘发起一次io请求，然后会把硬盘上的数据，同步到内核态的PageCache中，相当于和sendfile没有什么区别。</p><p><img src="'+c+'" alt="img_216.png" loading="lazy"></p><p>接下来就是适用splice()的地方。</p><p>它需要在网卡设备，和内核态的PageCache之间，建立一个管道， 然后将数据从网卡设备，拷贝到内核态的PageCache中，然后通过splice()，将数据从内核态的PageCache，拷贝到用户态的缓冲区中。</p><p>它需要在网卡设备（和PageCache之间搭建一个环形的管道）</p><p><img src="'+o+'" alt="img_217.png" loading="lazy"></p><p><img src="'+_+'" alt="img_218.png" loading="lazy"></p>',12),r=[l];function g(m,d,f,h,k,v){return s(),e("div",null,r)}const D=a(n,[["render",g]]);export{P as __pageData,D as default};
