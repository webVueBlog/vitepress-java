import{_ as s,c as a,o as t,a8 as i}from"./chunks/framework.DDO5B0CJ.js";const e="/vitepress-java/assets/img_148.Del8qtSy.png",p="/vitepress-java/assets/img_149.BDnrSWyp.png",_="/vitepress-java/assets/img_150.CpjkMOz1.png",n="/vitepress-java/assets/img_151.BeTWkqGm.png",g="/vitepress-java/assets/img_152.CjWnGmeY.png",r="/vitepress-java/assets/img_153.CGvlE0wm.png",o="/vitepress-java/assets/img_154.BzP34PV5.png",m="/vitepress-java/assets/img_155.lpN35H2K.png",l="/vitepress-java/assets/img_156.W6tlQ5NZ.png",c="/vitepress-java/assets/img_157.CFz4vveB.png",S=JSON.parse('{"title":"7.3-基于Redis实现分布式锁的几种坑你是否踩过《下》","description":"","frontmatter":{},"headers":[],"relativePath":"Redis6/36.md","filePath":"Redis6/36.md"}'),d={name:"Redis6/36.md"},v=i('<h1 id="_7-3-基于redis实现分布式锁的几种坑你是否踩过《下》" tabindex="-1">7.3-基于Redis实现分布式锁的几种坑你是否踩过《下》 <a class="header-anchor" href="#_7-3-基于redis实现分布式锁的几种坑你是否踩过《下》" aria-label="Permalink to &quot;7.3-基于Redis实现分布式锁的几种坑你是否踩过《下》&quot;">​</a></h1><p><img src="'+e+'" alt="img_148.png" loading="lazy"></p><p><img src="'+p+'" alt="img_149.png" loading="lazy"></p><p><img src="'+_+'" alt="img_150.png" loading="lazy"></p><p><img src="'+n+'" alt="img_151.png" loading="lazy"></p><p><img src="'+g+'" alt="img_152.png" loading="lazy"></p><p>就是业务超时，存在其他线程误删的情况，key30秒过期，a线程 执行很慢 超过30秒， 则 key 被释放了，其他线程 b 得到了锁， 此时 a 线程 完成了业务逻辑， 最终去释放锁，（这个时候 就会误删了其他线程的锁， 导致死锁），而 b 线程 还没有执行完成。</p><p>结果线程 a 删除了 线程 b 加的锁。</p><p><img src="'+r+'" alt="img_153.png" loading="lazy"></p><p><img src="'+o+'" alt="img_154.png" loading="lazy"></p><p><img src="'+m+'" alt="img_155.png" loading="lazy"></p><p><img src="'+l+'" alt="img_156.png" loading="lazy"></p><p><img src="'+c+'" alt="img_157.png" loading="lazy"></p>',13),y=[v];function z(j,h,f,k,u,P){return t(),a("div",null,y)}const T=s(d,[["render",z]]);export{S as __pageData,T as default};
