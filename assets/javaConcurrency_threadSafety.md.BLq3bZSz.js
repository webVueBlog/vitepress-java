import{_ as a,c as e,o as t,a8 as i}from"./chunks/framework.CbRyzB36.js";const p="/vitepress-java/assets/img_77.BhPj3nRi.png",r="/vitepress-java/assets/img_78.BYgo574P.png",n="/vitepress-java/assets/img_79.rWSy53L8.png",s="/vitepress-java/assets/img_80.fv-Efpst.png",o="/vitepress-java/assets/img_81.SIqc9qrD.png",l="/vitepress-java/assets/img_82.DaFZ_qOM.png",c="/vitepress-java/assets/img_83.B-l4tOmh.png",g="/vitepress-java/assets/img_84.CtL25Pjf.png",d="data:image/png;base64,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",h="/vitepress-java/assets/img_86.1V0E7R-L.png",m="/vitepress-java/assets/img_87.Cgx8Z36U.png",A="/vitepress-java/assets/img_88.D_mNEr7W.png",u="/vitepress-java/assets/img_89.D-LAUyB0.png",f="/vitepress-java/assets/img_90.Dw8zqG3n.png",v="/vitepress-java/assets/img_91.Biruut8h.png",D=JSON.parse('{"title":"十一、线程安全","description":"","frontmatter":{},"headers":[],"relativePath":"javaConcurrency/threadSafety.md","filePath":"javaConcurrency/threadSafety.md"}'),b={name:"javaConcurrency/threadSafety.md"},L=i('<h1 id="十一、线程安全" tabindex="-1">十一、线程安全 <a class="header-anchor" href="#十一、线程安全" aria-label="Permalink to &quot;十一、线程安全&quot;">​</a></h1><p>线程安全有以下几种实现方式：</p><blockquote><p>不可变</p></blockquote><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障 措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中 处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型：</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变 的。</li></ul><p><img src="'+p+'" alt="img_77.png" loading="lazy"></p><p><img src="'+r+'" alt="img_78.png" loading="lazy"></p><p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方 法都直接抛出异常</p><p><img src="'+n+'" alt="img_79.png" loading="lazy"></p><blockquote><p>互斥同步</p></blockquote><p>synchronized 和 ReentrantLock。</p><blockquote><p>非阻塞同步</p></blockquote><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为 阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定 会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概 念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维 护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作， 如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重 试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这 种同步操作称为非阻塞同步。</p><h2 id="_1-cas" tabindex="-1">1. CAS <a class="header-anchor" href="#_1-cas" aria-label="Permalink to &quot;1. CAS&quot;">​</a></h2><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保 证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换 （Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、 旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><h2 id="_2-atomicinteger" tabindex="-1">2. AtomicInteger <a class="header-anchor" href="#_2-atomicinteger" aria-label="Permalink to &quot;2. AtomicInteger&quot;">​</a></h2><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。 以下代码使用了 AtomicInteger 执行了自增的操作。</p><p><img src="'+s+'" alt="img_80.png" loading="lazy"></p><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><p><img src="'+o+'" alt="img_81.png" loading="lazy"></p><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对 象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字 段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><p><img src="'+l+'" alt="img_82.png" loading="lazy"></p><h2 id="_3-aba" tabindex="-1">3. ABA <a class="header-anchor" href="#_3-aba" aria-label="Permalink to &quot;3. ABA&quot;">​</a></h2><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问 题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题 不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会 比原子类更高效。</p><blockquote><p>无同步方案</p></blockquote><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据， 那它自然就无须任何同步措施去保证正确性。</p><h2 id="_1-栈封闭" tabindex="-1">1. 栈封闭 <a class="header-anchor" href="#_1-栈封闭" aria-label="Permalink to &quot;1. 栈封闭&quot;">​</a></h2><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储 在虚拟机栈中，属于线程私有的</p><p><img src="'+c+'" alt="img_83.png" loading="lazy"></p><p><img src="'+g+'" alt="img_84.png" loading="lazy"></p><p><img src="'+d+'" alt="img_85.png" loading="lazy"></p><h2 id="_2-线程本地存储-thread-local-storage" tabindex="-1">2. 线程本地存储（Thread Local Storage） <a class="header-anchor" href="#_2-线程本地存储-thread-local-storage" aria-label="Permalink to &quot;2. 线程本地存储（Thread Local Storage）&quot;">​</a></h2><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是 否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制 在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费 者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用 实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-perRequest）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使 用线程本地存储来解决线程安全问题。</p><p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。 过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><p><img src="'+h+'" alt="img_86.png" loading="lazy"></p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>为了理解 ThreadLocal，先看以下代码：</p><p><img src="'+m+'" alt="img_87.png" loading="lazy"></p><p><img src="'+A+'" alt="img_88.png" loading="lazy"></p><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p><p><img src="'+u+'" alt="img_89.png" loading="lazy"></p><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p><p><img src="'+f+'" alt="img_90.png" loading="lazy"></p><p>get() 方法类似。</p><p><img src="'+v+'" alt="img_91.png" loading="lazy"></p><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程 竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据 结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手 动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱 的风险</p><h2 id="_3-可重入代码-reentrant-code" tabindex="-1">3. 可重入代码（Reentrant Code） <a class="header-anchor" href="#_3-可重入代码-reentrant-code" aria-label="Permalink to &quot;3. 可重入代码（Reentrant Code）&quot;">​</a></h2><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去 执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出 现任何错误。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用 到的状态量都由参数中传入、不调用非可重入的方法等。</p>',57),_=[L];function k(B,P,S,y,j,z){return t(),e("div",null,_)}const x=a(b,[["render",k]]);export{D as __pageData,x as default};
