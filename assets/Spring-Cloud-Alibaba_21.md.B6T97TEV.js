import{_ as a,c as e,o as t,a8 as i}from"./chunks/framework.DDO5B0CJ.js";const n="/vitepress-java/assets/img_143.ZxQjzMnh.png",s="/vitepress-java/assets/img_144.r7ruh8aQ.png",p="/vitepress-java/assets/img_145.TkZHYNFa.png",r="/vitepress-java/assets/img_146.DO3VGLtS.png",l="/vitepress-java/assets/img_147.B9qK6tpo.png",o="/vitepress-java/assets/img_148.CT358kXa.png",y=JSON.parse('{"title":"21 Sentinel概念和功能","description":"","frontmatter":{},"headers":[],"relativePath":"Spring-Cloud-Alibaba/21.md","filePath":"Spring-Cloud-Alibaba/21.md"}'),_={name:"Spring-Cloud-Alibaba/21.md"},c=i('<h1 id="_21-sentinel概念和功能" tabindex="-1">21 Sentinel概念和功能 <a class="header-anchor" href="#_21-sentinel概念和功能" aria-label="Permalink to &quot;21 Sentinel概念和功能&quot;">​</a></h1><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h2><p><img src="'+n+'" alt="img_143.png" loading="lazy"></p><p>资源就是Sentinel要保护的任何东西，可以是Java应用程序中的任何方法，或者是一个网络连接等。</p><p>规则就是用来定义如何保护这些资源。</p><p><img src="'+s+'" alt="img_144.png" loading="lazy"></p><p><img src="'+p+'" alt="img_145.png" loading="lazy"></p><p><img src="'+r+'" alt="img_146.png" loading="lazy"></p><p>内存不够，CPU负载过高，网络延迟过高，磁盘IO过高等，都会导致系统性能下降，进而影响服务的可用性。</p><p><img src="'+l+'" alt="img_147.png" loading="lazy"></p><p><img src="'+o+'" alt="img_148.png" loading="lazy"></p><p>Sentinel通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。当某个资源的并发线程数超过阈值时，新的请求就会被拒绝，从而达到保护资源的目的。 堆积的线程完成后，会释放资源，继续处理新的请求。</p><p>通过响应时间对资源进行降级</p><p>除了对并发线程数进行控制以外，Sentinel还可以通过响应时间对资源进行降级。 当资源处理的响应时间超过阈值时，资源会被降级，即在接下来的降级时间窗口内，对该资源的访问都会被立即拒绝并返回相应的错误信息。</p><h2 id="sentinel-和-hystrix-的区别" tabindex="-1">Sentinel 和 Hystrix 的区别 <a class="header-anchor" href="#sentinel-和-hystrix-的区别" aria-label="Permalink to &quot;Sentinel 和 Hystrix 的区别&quot;">​</a></h2><p>两者的原则是一致的，都是当一个资源出现问题时，让其快速失败，不要涉及到其它服务</p><p>但是在限制的手段上，确采取了完全不一样的方法：</p><p>Hystrix 则是通过线程池的方式，来限制资源并发量，从而实现保护资源的目的。</p><p>Sentinel 则是通过限制资源并发线程的数量，来保护资源。</p><blockquote><p>Hystrix 实现方式是线程池隔离，而 Sentinel 实现方式是信号量隔离。</p><p>Hystrix 采用的是线程池隔离的方式，优点是做到了资源之间的隔离，缺点是增加了线程切换的成本。</p><p>Sentinel 采用的是通过并发线程的数量和响应时间来对资源进行保护，缺点是资源之间的隔离性没有 Hystrix 做的那么好。</p></blockquote><h2 id="系统负载保护" tabindex="-1">系统负载保护 <a class="header-anchor" href="#系统负载保护" aria-label="Permalink to &quot;系统负载保护&quot;">​</a></h2><p>Sentinel 同时提供系统维度的自适应保护能力。当系统负载较高时，自动触发流量控制，让请求快速失败，避免影响到其它的资源。当系统负载较高时，如果 还持续让请求进入，可能会导致系统崩溃，无法对外提供服务。在集群环境下，会把本应这台机器承载的流量转移走，待这台机器的负载降下来后再把请求转回来。</p>',22),g=[c];function m(d,h,S,u,b,x){return t(),e("div",null,g)}const f=a(_,[["render",m]]);export{y as __pageData,f as default};
