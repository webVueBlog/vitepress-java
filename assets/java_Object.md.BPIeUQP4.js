import{_ as s,c as a,o as n,a8 as p}from"./chunks/framework.CbRyzB36.js";const l="/vitepress-java/assets/img_33.Bu62W5vZ.png",e="/vitepress-java/assets/img_34.D26nf2xD.png",i="/vitepress-java/assets/img_35.Xd65nXoB.png",t="/vitepress-java/assets/img_36.Cmrs5gN2.png",r="/vitepress-java/assets/img_37.BX5qkrSp.png",c="/vitepress-java/assets/img_38.pKbPncRf.png",o="/vitepress-java/assets/img_39.Cm7_Wu53.png",u="/vitepress-java/assets/img_40.Cjv2OBIl.png",m="/vitepress-java/assets/img_41.BPGSvAcg.png",b="/vitepress-java/assets/img_42.DsgJjjMw.png",g="/vitepress-java/assets/img_43.Ckvl6s_o.png",d="/vitepress-java/assets/img_44.NZEF8v2C.png",_="/vitepress-java/assets/img_45.BSWBt5gD.png",v="/vitepress-java/assets/img_46.B0dfxX1s.png",w=JSON.parse('{"title":"五、Object 通用方法","description":"","frontmatter":{},"headers":[],"relativePath":"java/Object.md","filePath":"java/Object.md"}'),h={name:"java/Object.md"},x=p(`<h1 id="五、object-通用方法" tabindex="-1">五、Object 通用方法 <a class="header-anchor" href="#五、object-通用方法" aria-label="Permalink to &quot;五、Object 通用方法&quot;">​</a></h1><blockquote><p>概览</p></blockquote><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public native int hashCode()</span></span>
<span class="line"><span>public boolean equals(Object obj)</span></span>
<span class="line"><span>protected native Object clone() throws CloneNotSupportedException</span></span>
<span class="line"><span>public String toString()</span></span>
<span class="line"><span>public final native Class&lt;?&gt; getClass()</span></span>
<span class="line"><span>protected void finalize() throws Throwable {}</span></span>
<span class="line"><span>public final native void notify()</span></span>
<span class="line"><span>public final native void notifyAll()</span></span>
<span class="line"><span>public final native void wait(long timeout) throws</span></span>
<span class="line"><span>InterruptedException</span></span>
<span class="line"><span>public final void wait(long timeout, int nanos) throws</span></span>
<span class="line"><span>InterruptedException</span></span>
<span class="line"><span>public final void wait() throws InterruptedException</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>equals()</p><ol><li>等价关系</li></ol><p>两个对象具有等价关系，需要满足以下五个条件：</p><p>Ⅰ 自反性</p><p>x.equals(x); // true</p><p>Ⅱ 对称性</p><p>x.equals(y) == y.equals(x); // true</p><p>Ⅲ 传递性</p><p>if (x.equals(y) &amp;&amp; y.equals(z)) x.equals(z); // true;</p><p>Ⅳ 一致性</p><p>多次调用 equals() 方法结果不变</p><p>x.equals(y) == x.equals(y); // true</p><p>Ⅴ 与 null 的比较</p><p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p><p>x.equals(null); // false;</p><ol start="2"><li>等价与相等</li></ol><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对 象是否等价。</li></ul><p><img src="`+l+`" alt="img_33.png" loading="lazy"></p><ol start="3"><li>实现</li></ol><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public class EqualExample {</span></span>
<span class="line"><span>    private int x;</span></span>
<span class="line"><span>    private int y;</span></span>
<span class="line"><span>    private int z;</span></span>
<span class="line"><span>    public EqualExample(int x, int y, int z) {</span></span>
<span class="line"><span>        this.x = x;</span></span>
<span class="line"><span>        this.y = y;</span></span>
<span class="line"><span>        this.z = z;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public boolean equals(Object o) {</span></span>
<span class="line"><span>        if (this == o) return true;</span></span>
<span class="line"><span>        if (o == null || getClass() != o.getClass()) return false;</span></span>
<span class="line"><span>        EqualExample that = (EqualExample) o;</span></span>
<span class="line"><span>        if (x != that.x) return false;</span></span>
<span class="line"><span>        if (y != that.y) return false;</span></span>
<span class="line"><span>        return z == that.z;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><blockquote><p>hashCode()</p></blockquote><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象 散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有 随机性，两个值不同的对象可能计算出相同的哈希值。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也 相等。</p><p>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置， 因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这 两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价 的对象。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>EqualExample e1 = new EqualExample(1, 1, 1);</span></span>
<span class="line"><span>EqualExample e2 = new EqualExample(1, 1, 1);</span></span>
<span class="line"><span>System.out.println(e1.equals(e2)); // true</span></span>
<span class="line"><span>HashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();</span></span>
<span class="line"><span>set.add(e1);</span></span>
<span class="line"><span>set.add(e2);</span></span>
<span class="line"><span>System.out.println(set.size()); // 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值 上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制 的某一位，然后组成一个 R 进制的整数。</p><p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会 丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可 以转换成移位和减法： 31*x == (x&lt;&lt;5)-x ，编译器会自动进行这个优化。</p><p><img src="`+e+'" alt="img_34.png" loading="lazy"></p><blockquote><p>toString()</p></blockquote><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符 号十六进制表示。</p><p><img src="'+i+'" alt="img_35.png" loading="lazy"></p><p><img src="'+t+'" alt="img_36.png" loading="lazy"></p><p><img src="'+r+'" alt="img_37.png" loading="lazy"></p><blockquote><p>clone()</p></blockquote><ol><li>cloneable</li></ol><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()， 其它类就不能直接去调用该类实例的 clone() 方法。</p><p><img src="'+c+'" alt="img_38.png" loading="lazy"></p><p><img src="'+o+'" alt="img_39.png" loading="lazy"></p><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用 了 clone() 方法，就会抛出 CloneNotSupportedException。</p><p><img src="'+u+'" alt="img_40.png" loading="lazy"></p><ol start="2"><li>浅拷贝</li></ol><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><p><img src="'+m+'" alt="img_41.png" loading="lazy"></p><p><img src="'+b+'" alt="img_42.png" loading="lazy"></p><ol start="3"><li>深拷贝</li></ol><p>拷贝对象和原始对象的引用类型引用不同对象。</p><p><img src="'+g+'" alt="img_43.png" loading="lazy"></p><p><img src="'+d+'" alt="img_44.png" loading="lazy"></p><ol start="4"><li>clone() 的替代方案</li></ol><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型 转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或 者拷贝工厂来拷贝一个对象。</p><p><img src="'+_+'" alt="img_45.png" loading="lazy"></p><p><img src="'+v+'" alt="img_46.png" loading="lazy"></p>',58),q=[x];function j(y,f,C,E,z,k){return n(),a("div",null,q)}const O=s(h,[["render",j]]);export{w as __pageData,O as default};
