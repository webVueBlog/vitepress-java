import{_ as a,c as e,o as s,a8 as n}from"./chunks/framework.CbRyzB36.js";const r="/vitepress-java/assets/img_43.rZQHnPFm.png",t="/vitepress-java/assets/img_44.D7VaznrL.png",i="/vitepress-java/assets/img_45.BLuS67R3.png",p="/vitepress-java/assets/img_46.5aOUHvk5.png",l="/vitepress-java/assets/img_47.B8OkUp0R.png",o="/vitepress-java/assets/img_48.0O7wqXAR.png",c="/vitepress-java/assets/img_49.Ctj1zR2A.png",j=JSON.parse('{"title":"七、J.U.C - AQS","description":"","frontmatter":{},"headers":[],"relativePath":"javaConcurrency/juc-aqs.md","filePath":"javaConcurrency/juc-aqs.md"}'),u={name:"javaConcurrency/juc-aqs.md"},d=n('<h1 id="七、j-u-c-aqs" tabindex="-1">七、J.U.C - AQS <a class="header-anchor" href="#七、j-u-c-aqs" aria-label="Permalink to &quot;七、J.U.C - AQS&quot;">​</a></h1><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><h2 id="countdownlatch" tabindex="-1">CountDownLatch <a class="header-anchor" href="#countdownlatch" aria-label="Permalink to &quot;CountDownLatch&quot;">​</a></h2><p>用来控制一个或者多个线程等待多个线程。</p><p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的 时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><p><img src="'+r+'" alt="img_43.png" loading="lazy"></p><p><img src="'+t+'" alt="img_44.png" loading="lazy"></p><p><img src="'+i+'" alt="img_45.png" loading="lazy"></p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>run..run..run..run..run..run..run..run..run..run..end</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="cyclicbarrier" tabindex="-1">CyclicBarrier <a class="header-anchor" href="#cyclicbarrier" aria-label="Permalink to &quot;CyclicBarrier&quot;">​</a></h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后 计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程 才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所 有线程都到达屏障的时候会执行一次。</p><p><img src="'+p+'" alt="img_46.png" loading="lazy"></p><p><img src="'+l+'" alt="img_47.png" loading="lazy"></p><p><img src="'+o+`" alt="img_48.png" loading="lazy"></p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>before..before..before..before..before..before..before..before..b</span></span>
<span class="line"><span>efore..before..after..after..after..after..after..after..after..a</span></span>
<span class="line"><span>fter..after..after..</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="semaphore" tabindex="-1">Semaphore <a class="header-anchor" href="#semaphore" aria-label="Permalink to &quot;Semaphore&quot;">​</a></h2><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总 数为 10。</p><p><img src="`+c+'" alt="img_49.png" loading="lazy"></p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>2 1 2 2 2 2 2 1 2 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>',23),m=[d];function g(h,_,b,v,f,C){return s(),e("div",null,m)}const k=a(u,[["render",g]]);export{j as __pageData,k as default};
