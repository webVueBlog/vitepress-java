import{_ as o,c as e,o as n,l as t,a}from"./chunks/framework.DDO5B0CJ.js";const b=JSON.parse('{"title":"SpringBoot可以同时处理多少请求","description":"","frontmatter":{},"headers":[],"relativePath":"SpringBoot/1.md","filePath":"SpringBoot/1.md"}'),c={name:"SpringBoot/1.md"},s=t("h1",{id:"springboot可以同时处理多少请求",tabindex:"-1"},[a("SpringBoot可以同时处理多少请求 "),t("a",{class:"header-anchor",href:"#springboot可以同时处理多少请求","aria-label":'Permalink to "SpringBoot可以同时处理多少请求"'},"​")],-1),r=t("p",null,"SpringBoot默认的内嵌容器是Tomcat，也就是我们的程序实际上是运行在Tomcat里的。 所以与其说SpringBoot可以处理多少请求，到不如说Tomcat可以处理多少请求。",-1),i=t("p",null,"在SpringBoot中处理请求数量相关的参数有四个：",-1),p=t("p",null,"server.tomcat.threads.min-spare：最少的工作线程数，默认大小是10。该参数相当于长期工，如果并发请求的数量达不到10， 就会依次使用这几个线程去处理请求。",-1),_=t("p",null,"server.tomcat.threads.max：最多的工作线程数，默认大小是200。该参数相当于临时工，如果并发请求的数量在10到200之间， 就会使用这些临时工线程进行处理。",-1),l=t("p",null,"server.tomcat.max-connections：最大连接数，默认大小是8192。表示Tomcat可以处理的最大请求数量，超过8192的请求就会被放入到等待队列。",-1),d=t("p",null,"server.tomcat.accept-count：等待队列的长度，默认大小是100。",-1),m=t("p",null,"如果把Tomcat比作一家饭店的话，那么一个请求其实就相当于一位客人。 min-spare就是厨师(长期工)；max是厨师总数(长期工+临时工)；max-connections就是饭店里的座位数量；accept-count是门口小板凳的数量。 来的客人优先坐到饭店里面，然后厨师开始忙活，如果长期工可以干的完，就让长期工干，如果长期工干不完，就再让临时工干。 图中画的厨师一共15人，饭店里有30个座位，也就是说，如果现在来了20个客人，那么就会有5个人先在饭店里等着。 如果现在来了35个人，饭店里坐不下，就会让5个人先到门口坐一下。如果来了50个人，那么饭店座位+门口小板凳一共40个，所以就会有10人离开。 也就是说，SpringBoot同时所能处理的最大请求数量是max-connections+accept-count，超过该数量的请求直接就会被丢掉。",-1),h=[s,r,i,p,_,l,d,m];function u(g,B,S,x,f,v){return n(),e("div",null,h)}const $=o(c,[["render",u]]);export{b as __pageData,$ as default};
