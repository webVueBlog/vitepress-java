import{_ as a,c as e,o as r,a8 as t}from"./chunks/framework.CbRyzB36.js";const s="/vitepress-java/assets/img.BiQDP7vH.png",l="/vitepress-java/assets/img_1.yfOEI-G5.png",n="/vitepress-java/assets/img_2.BhFJp9FH.png",i="/vitepress-java/assets/img_3.CaP5L_DW.png",p="/vitepress-java/assets/img_4.B_gRJR9J.png",o="/vitepress-java/assets/img_5.ByMqr8k1.png",q=JSON.parse('{"title":"一、使用线程","description":"","frontmatter":{},"headers":[],"relativePath":"javaConcurrency/useThread.md","filePath":"javaConcurrency/useThread.md"}'),d={name:"javaConcurrency/useThread.md"},h=t('<h1 id="一、使用线程" tabindex="-1">一、使用线程 <a class="header-anchor" href="#一、使用线程" aria-label="Permalink to &quot;一、使用线程&quot;">​</a></h1><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真 正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程 驱动从而执行的</p><h2 id="实现-runnable-接口" tabindex="-1">实现 Runnable 接口 <a class="header-anchor" href="#实现-runnable-接口" aria-label="Permalink to &quot;实现 Runnable 接口&quot;">​</a></h2><p>需要实现接口中的 run() 方法。</p><p><img src="'+s+'" alt="img.png" loading="lazy"></p><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来 启动线程。</p><p><img src="'+l+'" alt="img_1.png" loading="lazy"></p><h2 id="实现-callable-接口" tabindex="-1">实现 Callable 接口 <a class="header-anchor" href="#实现-callable-接口" aria-label="Permalink to &quot;实现 Callable 接口&quot;">​</a></h2><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装</p><p><img src="'+n+'" alt="img_2.png" loading="lazy"></p><p><img src="'+i+'" alt="img_3.png" loading="lazy"></p><h2 id="继承-thread-类" tabindex="-1">继承 Thread 类 <a class="header-anchor" href="#继承-thread-类" aria-label="Permalink to &quot;继承 Thread 类&quot;">​</a></h2><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度， 当一个线程被调度时会执行该线程的 run() 方法</p><p><img src="'+p+'" alt="img_4.png" loading="lazy"></p><p><img src="'+o+'" alt="img_5.png" loading="lazy"></p><h2 id="实现接口-vs-继承-thread" tabindex="-1">实现接口 VS 继承 Thread <a class="header-anchor" href="#实现接口-vs-继承-thread" aria-label="Permalink to &quot;实现接口 VS 继承 Thread&quot;">​</a></h2><p>实现接口会更好一些，因为：</p><p>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现 多个接口；</p><p>类可能只要求可执行就行，继承整个 Thread 类开销过大。</p>',22),_=[h];function c(g,m,u,b,T,v){return r(),e("div",null,_)}const y=a(d,[["render",c]]);export{q as __pageData,y as default};
