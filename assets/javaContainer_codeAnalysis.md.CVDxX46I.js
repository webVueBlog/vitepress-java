import{_ as a,c as s,o as n,a8 as p}from"./chunks/framework.DDO5B0CJ.js";const e="/vitepress-java/assets/img_4.Dm6gEoXe.png",i="/vitepress-java/assets/img_5.BXpdoCKO.png",t="/vitepress-java/assets/img_6.Dn6jRcjh.png",l="/vitepress-java/assets/img_7.B286UV66.png",r="/vitepress-java/assets/img_8.BsHVs2qa.png",c="/vitepress-java/assets/img_9.B7WgZhfD.png",o="/vitepress-java/assets/img_10.sxczic8T.png",g="/vitepress-java/assets/img_11.Db2JO_a3.png",m="/vitepress-java/assets/img_12.Cq8bIAY5.png",d="/vitepress-java/assets/img_13.p2uLg0z6.png",h="/vitepress-java/assets/img_14.DYvB3gAW.png",u="/vitepress-java/assets/img_15.BjCfpRWo.png",b="/vitepress-java/assets/img_16.lX4ZpLmF.png",v="/vitepress-java/assets/img_17.SCHNcZVJ.png",_="/vitepress-java/assets/img_18.BEhkCsyX.png",y="/vitepress-java/assets/img_19.DrqZaXSt.png",k="/vitepress-java/assets/img_20.B-pNzr_0.png",C="/vitepress-java/assets/img_21.BX_XG2CG.png",j="/vitepress-java/assets/img_22.VY53Ljam.png",z="/vitepress-java/assets/img_23.CTSWvd-m.png",L="/vitepress-java/assets/img_24.C5S1cANB.png",A="/vitepress-java/assets/img_25.bTA_zRhH.png",M="/vitepress-java/assets/img_26.DwoUtwaZ.png",w="/vitepress-java/assets/img_27.BPPP0zxw.png",f="/vitepress-java/assets/img_28.Dgzt8dhH.png",q="/vitepress-java/assets/img_29.eWEkTraW.png",E="/vitepress-java/assets/img_30.PgjKTfwj.png",H="/vitepress-java/assets/img_31.BMXWFZOE.png",O="/vitepress-java/assets/img_32.GfoTuGAp.png",x="/vitepress-java/assets/img_33.CqUdg7Dl.png",S="/vitepress-java/assets/img_34.Cba5aA3j.png",K="/vitepress-java/assets/img_35.D0YTZGNw.png",V="/vitepress-java/assets/img_36.BI_WFP_5.png",D="/vitepress-java/assets/img_37.PIxy-a-x.png",N="/vitepress-java/assets/img_38.B4XQmd5G.png",W="/vitepress-java/assets/img_39.DqIPGIlh.png",R="/vitepress-java/assets/img_40.CuCj85mo.png",T="/vitepress-java/assets/img_41.DTJ1N5dt.png",I="/vitepress-java/assets/img_42.CaMnLKI6.png",P="/vitepress-java/assets/img_43.Da4N8e8v.png",B="/vitepress-java/assets/img_44.Dxd8Ylgy.png",J="/vitepress-java/assets/img_45.BpZgz5h3.png",U="/vitepress-java/assets/img_46.nEGtpF5v.png",X="/vitepress-java/assets/img_47.-AwcJUY7.png",F="/vitepress-java/assets/img_48.DkiymIii.png",G="/vitepress-java/assets/img_49.CULuMl_1.png",Z="/vitepress-java/assets/img_50.CKEQjc_W.png",Y="/vitepress-java/assets/img_51.B-dZq896.png",$="/vitepress-java/assets/img_52.C6ItJiWv.png",Q="/vitepress-java/assets/img_53.DlNEXyaq.png",aa="/vitepress-java/assets/img_54.CbPIAN74.png",sa="/vitepress-java/assets/img_55.sabGXAEO.png",na="/vitepress-java/assets/img_56.C9sxEWOh.png",pa="/vitepress-java/assets/img_57.Cids5Gxg.png",ea="/vitepress-java/assets/img_58.BC21BLuT.png",ia="/vitepress-java/assets/img_59.De5GlXRm.png",ta="/vitepress-java/assets/img_60.Bqeytrfu.png",la="/vitepress-java/assets/img_61.gd3uxkRe.png",ya=JSON.parse('{"title":"三、源码分析","description":"","frontmatter":{},"headers":[],"relativePath":"javaContainer/codeAnalysis.md","filePath":"javaContainer/codeAnalysis.md"}'),ra={name:"javaContainer/codeAnalysis.md"},ca=p(`<h1 id="三、源码分析" tabindex="-1">三、源码分析 <a class="header-anchor" href="#三、源码分析" aria-label="Permalink to &quot;三、源码分析&quot;">​</a></h1><p>基于 JDK 1.8。</p><p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅 读源码。</p><h2 id="arraylist" tabindex="-1">ArrayList <a class="header-anchor" href="#arraylist" aria-label="Permalink to &quot;ArrayList&quot;">​</a></h2><ol><li>概览</li></ol><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识 着该类支持快速随机访问。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span></span>
<span class="line"><span>implements List&lt;E&gt;, RandomAccess, Cloneable,</span></span>
<span class="line"><span>java.io.Serializable</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>数组的默认大小为 10。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>private static final int DEFAULT_CAPACITY = 10;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="`+e+'" alt="img_4.png" loading="lazy"></p><ol start="2"><li>扩容</li></ol><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使 用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code> ，即 <code>oldCapacity+oldCapacity/2</code>。其中 <code>oldCapacity &gt;&gt; 1</code> 需要取整，所以新容量大 约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）</p><p>扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代 价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的 次数。</p><p><img src="'+i+'" alt="img_5.png" loading="lazy"></p><p><img src="'+t+'" alt="img_6.png" loading="lazy"></p><p><img src="'+l+'" alt="img_7.png" loading="lazy"></p><ol start="3"><li>删除元素</li></ol><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作 的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p><p><img src="'+r+`" alt="img_8.png" loading="lazy"></p><ol start="4"><li>序列化</li></ol><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会 被使用，那么就没必要全部进行序列化。</p><p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列 化。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>transient Object[] elementData; // non-private to simplify nested</span></span>
<span class="line"><span>class access</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部 分内容。</p><p><img src="`+c+'" alt="img_9.png" loading="lazy"></p><p><img src="'+o+'" alt="img_10.png" loading="lazy"></p><p><img src="'+g+`" alt="img_11.png" loading="lazy"></p><p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。 而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方 法，原理类似。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>ArrayList list = new ArrayList();</span></span>
<span class="line"><span>ObjectOutputStream oos = new ObjectOutputStream(new</span></span>
<span class="line"><span>FileOutputStream(file));</span></span>
<span class="line"><span>oos.writeObject(list);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="5"><li>Fail-Fast</li></ol><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除 至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算 结构发生变化。</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变 了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p><h2 id="vector" tabindex="-1">Vector <a class="header-anchor" href="#vector" aria-label="Permalink to &quot;Vector&quot;">​</a></h2><ol><li>同步</li></ol><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p><p><img src="`+m+'" alt="img_12.png" loading="lazy"></p><ol start="2"><li>扩容</li></ol><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p><p><img src="'+d+'" alt="img_13.png" loading="lazy"></p><p><img src="'+h+'" alt="img_14.png" loading="lazy"></p><p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是 说默认情况下 Vector 每次扩容时容量都会翻倍。</p><p><img src="'+u+`" alt="img_15.png" loading="lazy"></p><ol start="3"><li>与 ArrayList 的比较</li></ol><p>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</p><p>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</p><ol start="4"><li>替代方案</li></ol><p>可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span>
<span class="line"><span>List&lt;String&gt; synList = Collections.synchronizedList(list);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="copyonwritearraylist" tabindex="-1">CopyOnWriteArrayList <a class="header-anchor" href="#copyonwritearraylist" aria-label="Permalink to &quot;CopyOnWriteArrayList&quot;">​</a></h2><ol><li>读写分离</li></ol><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影 响</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><p><img src="`+b+'" alt="img_16.png" loading="lazy"></p><p><img src="'+v+'" alt="img_17.png" loading="lazy"></p><p><img src="'+_+'" alt="img_18.png" loading="lazy"></p><ol start="2"><li>适用场景</li></ol><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此 很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：</p><p>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左 右；</p><p>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到 读数组中。</p><p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景.</p><h2 id="linkedlist" tabindex="-1">LinkedList <a class="header-anchor" href="#linkedlist" aria-label="Permalink to &quot;LinkedList&quot;">​</a></h2><ol><li>概览</li></ol><p>基于双向链表实现，使用 Node 存储链表节点信息。</p><p><img src="'+y+`" alt="img_19.png" loading="lazy"></p><p>每个链表存储了 first 和 last 指针：</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>transient Node&lt;E&gt; first;</span></span>
<span class="line"><span>transient Node&lt;E&gt; last;// 尾指针</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="`+k+'" alt="img_20.png" loading="lazy"></p><ol start="2"><li>与 ArrayList 的比较</li></ol><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p><ul><li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li><li>链表不支持随机访问，但插入删除只需要改变指针。</li></ul><h2 id="hashmap" tabindex="-1">HashMap <a class="header-anchor" href="#hashmap" aria-label="Permalink to &quot;HashMap&quot;">​</a></h2><p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p><ol><li>存储结构</li></ol><p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段， 从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶， 一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值 和散列桶取模运算结果相同的 Entry。</p><p><img src="'+C+'" alt="img_21.png" loading="lazy"></p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>transient Entry[] table;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="'+j+'" alt="img_22.png" loading="lazy"></p><p><img src="'+z+'" alt="img_23.png" loading="lazy"></p><p><img src="'+L+'" alt="img_24.png" loading="lazy"></p><p><img src="'+A+'" alt="img_25.png" loading="lazy"></p><p><img src="'+M+`" alt="img_26.png" loading="lazy"></p><ol start="2"><li>拉链法的工作原理</li></ol><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span></span>
<span class="line"><span>map.put(&quot;K1&quot;, &quot;V1&quot;);</span></span>
<span class="line"><span>map.put(&quot;K2&quot;, &quot;V2&quot;);</span></span>
<span class="line"><span>map.put(&quot;K3&quot;, &quot;V3&quot;);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>新建一个 HashMap，默认大小为 16；</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>插入 &lt; K1,V1 &gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所</span></span>
<span class="line"><span>在的桶下标 115%16=3。</span></span>
<span class="line"><span>插入 &lt; K2,V2 &gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所</span></span>
<span class="line"><span>在的桶下标 118%16=6。</span></span>
<span class="line"><span>插入 &lt; K3,V3 &gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所</span></span>
<span class="line"><span>在的桶下标 118%16=6，插在 &lt; K2,V2 &gt; 前面。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>应该注意到链表的插入是以头插法方式进行的，例如上面的 <code>&lt;K3,V3&gt;</code> 不是插在 <code>&lt;K2,V2&gt;</code> 后面，而是插入在链表头部。</p><p>查找需要分成两步进行：</p><ul><li>计算键值对所在的桶；</li><li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li></ul><p><img src="`+w+'" alt="img_27.png" loading="lazy"></p><ol start="3"><li>put 操作</li></ol><p><img src="'+f+'" alt="img_28.png" loading="lazy"></p><p><img src="'+q+'" alt="img_29.png" loading="lazy"></p><p><img src="'+E+'" alt="img_30.png" loading="lazy"></p><p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法， 也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p><p><img src="'+H+'" alt="img_31.png" loading="lazy"></p><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部</p><p><img src="'+O+'" alt="img_32.png" loading="lazy"></p><p><img src="'+x+`" alt="img_33.png" loading="lazy"></p><ol start="4"><li>确定桶下标</li></ol><p>很多操作都需要先确定一个键值对所在的桶下标。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>int hash = hash(key);</span></span>
<span class="line"><span>int i = indexFor(hash, table.length);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>4.1 计算 hash 值</p><p><img src="`+S+'" alt="img_34.png" loading="lazy"></p><p><img src="'+K+'" alt="img_35.png" loading="lazy"></p><p><img src="'+V+`" alt="img_36.png" loading="lazy"></p><p>4.2 取模</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>x : 00010000</span></span>
<span class="line"><span>x-1 : 00001111</span></span>
<span class="line"><span></span></span>
<span class="line"><span>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>y : 10110010</span></span>
<span class="line"><span>x-1 : 00001111</span></span>
<span class="line"><span>y&amp;(x-1) : 00000010</span></span>
<span class="line"><span></span></span>
<span class="line"><span>这个性质和 y 对 x 取模效果是一样的：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>y : 10110010</span></span>
<span class="line"><span>x : 00010000</span></span>
<span class="line"><span>y%x : 00000010</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能 带来更高的性能。</p><p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保 证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>static int indexFor(int h, int length) {</span></span>
<span class="line"><span>return h &amp; (length-1);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="5"><li>扩容-基本原理</li></ol><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均 匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p><p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是 说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得 空间效率和时间效率都能得到保证。</p><p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p><p><img src="`+D+'" alt="img_37.png" loading="lazy"></p><p><img src="'+N+'" alt="img_38.png" loading="lazy"></p><p><img src="'+W+'" alt="img_39.png" loading="lazy"></p><p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p><p><img src="'+R+'" alt="img_40.png" loading="lazy"></p><p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对 重新插入 newTable 中，因此这一步是很费时的。</p><p><img src="'+T+'" alt="img_41.png" loading="lazy"></p><p><img src="'+I+`" alt="img_42.png" loading="lazy"></p><ol start="6"><li>扩容-重新计算桶下标</li></ol><p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到， HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特 点能够极大降低重新计算桶下标操作的复杂度。</p><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>capacity : 00010000</span></span>
<span class="line"><span>new capacity : 00100000</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>对于一个 Key，它的哈希值 hash 在第 5 位：</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</span></span>
<span class="line"><span>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="7"><li>计算数组容量</li></ol><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入 的容量转换为 2 的 n 次方。</p><p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下 方法得到：</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>mask |= mask &gt;&gt; 1 11011000</span></span>
<span class="line"><span>mask |= mask &gt;&gt; 2 11111110</span></span>
<span class="line"><span>mask |= mask &gt;&gt; 4 11111111</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>num 10010000</span></span>
<span class="line"><span>mask+1 100000000</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>以下是 HashMap 中计算数组容量的代码：</p><p><img src="`+P+'" alt="img_43.png" loading="lazy"></p><ol start="8"><li>链表转红黑树</li></ol><p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p><ol start="9"><li><p>与 Hashtable 的比较</p></li><li><p>Hashtable 使用 synchronized 来进行同步。</p></li><li><p>HashMap 可以插入键为 null 的 Entry。</p></li><li><p>HashMap 的迭代器是 fail-fast 迭代器。</p></li><li><p>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</p></li></ol><h2 id="concurrenthashmap" tabindex="-1">ConcurrentHashMap <a class="header-anchor" href="#concurrenthashmap" aria-label="Permalink to &quot;ConcurrentHashMap&quot;">​</a></h2><ol><li>存储结构</li></ol><p><img src="'+B+'" alt="img_44.png" loading="lazy"></p><p><img src="'+J+'" alt="img_45.png" loading="lazy"></p><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以 同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个 数）。</p><p>Segment 继承自 ReentrantLock。</p><p><img src="'+U+'" alt="img_46.png" loading="lazy"></p><p><img src="'+X+`" alt="img_47.png" loading="lazy"></p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>final Segment&lt;K,V&gt;[] segments;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>static final int DEFAULT_CONCURRENCY_LEVEL = 16;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="2"><li>size 操作</li></ol><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>/**</span></span>
<span class="line"><span>* The number of elements. Accessed only either within locks</span></span>
<span class="line"><span>* or among other volatile reads that maintain visibility.</span></span>
<span class="line"><span>*/</span></span>
<span class="line"><span>transient int count;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p><p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到 的结果一致，那么可以认为这个结果是正确的。</p><p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此 尝试次数为 3。</p><p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><p><img src="`+F+'" alt="img_48.png" loading="lazy"></p><p><img src="'+G+'" alt="img_49.png" loading="lazy"></p><p><img src="'+Z+'" alt="img_50.png" loading="lazy"></p><p><img src="'+Y+'" alt="img_51.png" loading="lazy"></p><p><img src="'+$+`" alt="img_52.png" loading="lazy"></p><ol start="3"><li>JDK 1.8 的改动</li></ol><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p><p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p><p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p><h2 id="linkedhashmap" tabindex="-1">LinkedHashMap <a class="header-anchor" href="#linkedhashmap" aria-label="Permalink to &quot;LinkedHashMap&quot;">​</a></h2><p>存储结构</p><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements</span></span>
<span class="line"><span>Map&lt;K,V&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p><p><img src="`+Q+`" alt="img_53.png" loading="lazy"></p><p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>final boolean accessOrder;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中 调用。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>void afterNodeAccess(Node&lt;K,V&gt; p) { }</span></span>
<span class="line"><span>void afterNodeInsertion(boolean evict) { }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>afterNodeAccess()</p></blockquote><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就 是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部， 保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><p><img src="`+aa+'" alt="img_54.png" loading="lazy"></p><p><img src="'+sa+'" alt="img_55.png" loading="lazy"></p><blockquote><p>afterNodeInsertion()</p></blockquote><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点， 也就是链表首部节点 first。</p><p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><p><img src="'+na+'" alt="img_56.png" loading="lazy"></p><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并 且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使 用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><p><img src="'+pa+'" alt="img_57.png" loading="lazy"></p><blockquote><p>LRU 缓存</p></blockquote><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ol><li>设定最大缓存空间 MAX_ENTRIES 为 3；</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最 久未使用的数据移除。</li></ol><p><img src="'+ea+'" alt="img_58.png" loading="lazy"></p><p><img src="'+ia+`" alt="img_59.png" loading="lazy"></p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>[3, 1, 4]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="weakhashmap" tabindex="-1">WeakHashMap <a class="header-anchor" href="#weakhashmap" aria-label="Permalink to &quot;WeakHashMap&quot;">​</a></h2><blockquote><p>存储结构</p></blockquote><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一 次垃圾回收时会被回收。</p><p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt;</span></span>
<span class="line"><span>implements Map.Entry&lt;K,V&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="concurrentcache" tabindex="-1">ConcurrentCache <a class="header-anchor" href="#concurrentcache" aria-label="Permalink to &quot;ConcurrentCache&quot;">​</a></h3><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p><p>ConcurrentCache 采取的是分代缓存：</p><p>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会 被回收（伊甸园）；</p><p>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会 被垃圾收集器回收。</p><p>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获 取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容 易被回收。</p><p>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象 都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</p><p><img src="`+ta+'" alt="img_60.png" loading="lazy"></p><p><img src="'+la+'" alt="img_61.png" loading="lazy"></p>',210),oa=[ca];function ga(ma,da,ha,ua,ba,va){return n(),s("div",null,oa)}const ka=a(ra,[["render",ga]]);export{ya as __pageData,ka as default};
