import{_ as a,c as e,o as t,a8 as r}from"./chunks/framework.CbRyzB36.js";const i="/vitepress-java/assets/img.XEhFceA8.png",o="/vitepress-java/assets/img_1.WyH_X5An.png",q=JSON.parse('{"title":"第 1 章 对象入门","description":"","frontmatter":{},"headers":[],"relativePath":"ThinkingInJava/1.md","filePath":"ThinkingInJava/1.md"}'),h={name:"ThinkingInJava/1.md"},n=r('<h1 id="第-1-章-对象入门" tabindex="-1">第 1 章 对象入门 <a class="header-anchor" href="#第-1-章-对象入门" aria-label="Permalink to &quot;第 1 章 对象入门&quot;">​</a></h1><p>面向对象编程（OOP ）具有多方面的吸引力。对管理人员，它实现了更快和更廉价的开发与维护过程。对分析 与设计人员，建模处理变得更加简单，能生成清晰、易于维护的设计方案。对程序员，对象模型显得如此高 雅和浅显。此外，面向对象工具以及库的巨大威力使编程成为一项更使人愉悦的任务。每个人都可从中获 益，至少表面如此。</p><p>如果说它有缺点，那就是掌握它需付出的代价。思考对象的时候，需要采用形象思维，而不是程序化的思 维。与程序化设计相比，对象的设计过程更具挑战性——特别是在尝试创建可重复使用（可再生）的对象 时。</p><h2 id="_1-1-抽象的进步" tabindex="-1">1.1 抽象的进步 <a class="header-anchor" href="#_1-1-抽象的进步" aria-label="Permalink to &quot;1.1 抽象的进步&quot;">​</a></h2><p>在面向对象编程中，程序员把注意力从“如何实现”转移到“如何使用”。面向对象编程的抽象程度更高。</p><p>面向对象程序设计方法是什么样的：</p><p>(1)所有东西都是对象。可将对象想象成一种新型变量；它保存着数据，但可要求它对自身进行操作。理论 上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。</p><p>(2) 程序是一大堆对象的组合；通过消息传递，各对象知道自己该做些什么。为了向对象发出请求，需向那个对象“发送一条消息”。 更具体地讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个子例程或函数。</p><p>(3) 每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所 以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。</p><p>(4) 每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class） 是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。</p><p>(5) 同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法，大家不久便能理解。由于类型为 “圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收形状消 息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括 “圆”。这一特性称为对象的“可替换性”，是OOP 最重要的概念之一。</p><h2 id="_1-2-对象的接口" tabindex="-1">1.2 对象的接口 <a class="header-anchor" href="#_1-2-对象的接口" aria-label="Permalink to &quot;1.2 对象的接口&quot;">​</a></h2><p><img src="'+i+'" alt="img.png" loading="lazy"></p><h2 id="_1-3-实现方案的隐藏" tabindex="-1">1.3 实现方案的隐藏 <a class="header-anchor" href="#_1-3-实现方案的隐藏" aria-label="Permalink to &quot;1.3 实现方案的隐藏&quot;">​</a></h2><p>“public”（公共）意味着后续的定义任何人均可使 用。而在另一方面，“private”（私有）意味着除您自己、类型的创建者以及那个类型的内部函数成员，其 他任何人都不能访问后续的定义信息。private在您与客户程序员之间竖起了一堵墙。若有人试图访问私有 成员，就会得到一个编译期错误。“friendly”（友好的）涉及“包装”或“封装”（Package）的概念—— 即Java 用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访 问级别有时也叫作“包装访问”）。“protected”（受保护的）与“private”相似，只是一个继承的类可 访问受保护的成员，但不能访问私有成员。继承的问题不久就要谈到。</p><h2 id="_1-4-方案的重复使用" tabindex="-1">1.4 方案的重复使用 <a class="header-anchor" href="#_1-4-方案的重复使用" aria-label="Permalink to &quot;1.4 方案的重复使用&quot;">​</a></h2><p>创建并测试好一个类后，它应（从理想的角度）代表一个有用的代码单位。但并不象许多人希望的那样，这 种重复使用的能力并不容易实现；它要求较多的经验以及洞察力，这样才能设计出一个好的方案，才有可能 重复使用。</p><p>对象的组织具有极大的灵活性。新类的“成员对象”通常设为“私有”（Private），使用这个类的客户程序 员不能访问它们。这样一来，我们可在不干扰客户代码的前提下，从容地修改那些成员。也可以在“运行 期”更改成员，这进一步增大了灵活性。后面要讲到的“继承”并不具备这种灵活性，因为编译器必须对通 过继承创建的类加以限制。</p><p>由于继承的重要性，所以在面向对象的程序设计中，它经常被重点强调。作为新加入这一领域的程序员，或 许早已先入为主地认为“继承应当随处可见”。沿这种思路产生的设计将是非常笨拙的，会大大增加程序的 复杂程度。相反，新建类的时候，首先应考虑“组织”对象；这样做显得更加简单和灵活。利用对象的组 织，我们的设计可保持清爽。一旦需要用到继承，就会明显意识到这一点。</p><h2 id="_1-5-继承-重新使用接口" tabindex="-1">1.5 继承：重新使用接口 <a class="header-anchor" href="#_1-5-继承-重新使用接口" aria-label="Permalink to &quot;1.5 继承：重新使用接口&quot;">​</a></h2><p>在 Java 语言中，继承是通过 extends关键字实现的 使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private成员被隐藏 起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消 息亦可原样发给衍生类的对象。根据可以发送的消息，我们能知道类的类型。这意味着衍生类具有与基础类 相同的类型！为真正理解面向对象程序设计的含义，首先必须认识到这种类型的等价关系。</p><h3 id="_1-5-1-改善基础类" tabindex="-1">1.5.1 改善基础类 <a class="header-anchor" href="#_1-5-1-改善基础类" aria-label="Permalink to &quot;1.5.1 改善基础类&quot;">​</a></h3><p>尽管extends关键字暗示着我们要为接口“扩展”新功能，但实情并非肯定如此。为区分我们的新类，第二 个办法是改变基础类一个现有函数的行为。我们将其称作“改善”那个函数。</p><p>为改善一个函数，只需为衍生类的函数建立一个新定义即可。我们的目标是：“尽管使用的函数接口未变， 但它的新版本具有不同的表现”。</p><h3 id="_1-5-2-等价与类似关系" tabindex="-1">1.5.2 等价与类似关系 <a class="header-anchor" href="#_1-5-2-等价与类似关系" aria-label="Permalink to &quot;1.5.2 等价与类似关系&quot;">​</a></h3><p>针对继承可能会产生这样的一个争论：继承只能改善原基础类的函数吗？若答案是肯定的，则衍生类型就是 与基础类完全相同的类型，因为都拥有完全相同的接口。这样造成的结果就是：我们完全能够将衍生类的一 个对象换成基础类的一个对象！可将其想象成一种“纯替换”。在某种意义上，这是进行继承的一种理想方 式。此时，我们通常认为基础类和衍生类之间存在一种“等价”关系——因为我们可以理直气壮地说：“圆 就是一种几何形状”。为了对继承进行测试，一个办法就是看看自己是否能把它们套入这种“等价”关系 中，看看是否有意义。</p><h2 id="_1-6-多形对象的互换使用" tabindex="-1">1.6 多形对象的互换使用 <a class="header-anchor" href="#_1-6-多形对象的互换使用" aria-label="Permalink to &quot;1.6 多形对象的互换使用&quot;">​</a></h2><p><img src="'+o+'" alt="img_1.png" loading="lazy"></p><h3 id="_1-6-1-动态绑定" tabindex="-1">1.6.1 动态绑定 <a class="header-anchor" href="#_1-6-1-动态绑定" aria-label="Permalink to &quot;1.6.1 动态绑定&quot;">​</a></h3><p>对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态 绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是， 如何利用它帮助自己设计程序。</p><h3 id="_1-6-2-抽象的基础类和接口" tabindex="-1">1.6.2 抽象的基础类和接口 <a class="header-anchor" href="#_1-6-2-抽象的基础类和接口" aria-label="Permalink to &quot;1.6.2 抽象的基础类和接口&quot;">​</a></h3><p>设计程序时，我们经常都希望基础类只为自己的衍生类提供一个接口。也就是说，我们不想其他任何人实际 创建基础类的一个对象，只对上溯造型成它，以便使用它们的接口。为达到这个目的，需要把那个类变成 “抽象”的——使用abstract关键字。若有人试图创建抽象类的一个对象，编译器就会阻止他们。这种工具 可有效强制实行一种特殊的设计。</p><h2 id="_1-7-对象的创建和存在时间" tabindex="-1">1.7 对象的创建和存在时间 <a class="header-anchor" href="#_1-7-对象的创建和存在时间" aria-label="Permalink to &quot;1.7 对象的创建和存在时间&quot;">​</a></h2><p>最重要的问题之一是对象的创建及破坏方式。对象需要的数据位于哪儿，如何控制对象的“存在时间”呢？</p><h3 id="_1-7-1-集合与继承器" tabindex="-1">1.7.1 集合与继承器 <a class="header-anchor" href="#_1-7-1-集合与继承器" aria-label="Permalink to &quot;1.7.1 集合与继承器&quot;">​</a></h3><p>由于抽象是通过继承器进行的，所以能在两者方便地切换，对代码的影响则显得微不足道。 最后，记住集合只是一个用来放置对象的储藏所。如果那个储藏所能满足我们的所有需要，就完全没必要关 心它具体是如何实现的（这是大多数类型对象的一个基本概念）。如果在一个编程环境中工作，它由于其他 因素（比如在Windows 下运行，或者由垃圾收集器带来了开销）产生了内在的开销，那么矢量和链接列表之 间在系统开销上的差异就或许不是一个大问题。我们可能只需要一种类型的序列。甚至可以想象有一个“完 美”的集合抽象，它能根据自己的使用方式自动改变基层的实现方式。</p><h3 id="_1-7-2-单根结构" tabindex="-1">1.7.2 单根结构 <a class="header-anchor" href="#_1-7-2-单根结构" aria-label="Permalink to &quot;1.7.2 单根结构&quot;">​</a></h3><p>单根结构中的所有对象都有一个通用接口，所以它们最终都属于相同的类型。另一种方案（就象 C++ 那样） 是我们不能保证所有东西都属于相同的基本类型。从向后兼容的角度看，这一方案可与C 模型更好地配合， 而且可以认为它的限制更少一些。但假期我们想进行纯粹的面向对象编程，那么必须构建自己的结构，以期 获得与内建到其他 OOP 语言里的同样的便利。需添加我们要用到的各种新类库，还要使用另一些不兼容的接 口。理所当然地，这也需要付出额外的精力使新接口与自己的设计方案配合（可能还需要多重继承）。为得 到C++ 额外的“灵活性”，付出这样的代价值得吗？当然，如果真的需要——如果早已是 C 专家，如果对C 有难舍的情结——那么就真的很值得。但假如你是一名新手，首次接触这类设计，象Java 那样的替换方案也 许会更省事一些。</p><p>单根结构中的所有对象（比如所有 Java 对象）都可以保证拥有一些特定的功能。在自己的系统中，我们知道 对每个对象都能进行一些基本操作。一个单根结构，加上所有对象都在内存堆中创建，可以极大简化参数的 传递（这在 C++ 里是一个复杂的概念）。</p><h3 id="_1-7-3-集合库与方便使用集合" tabindex="-1">1.7.3 集合库与方便使用集合 <a class="header-anchor" href="#_1-7-3-集合库与方便使用集合" aria-label="Permalink to &quot;1.7.3 集合库与方便使用集合&quot;">​</a></h3><ol><li>下溯造型与模板／通用性</li></ol><p>为了使这些集合能够重复使用，或者“再生”，Java 提供了一种通用类型，以前曾把它叫作“Object”。单 根结构意味着、所有东西归根结底都是一个对象”！所以容纳了Object的一个集合实际可以容纳任何东西。 这使我们对它的重复使用变得非常简便</p>',42),l=[n];function p(s,d,_,c,u,b){return t(),e("div",null,l)}const f=a(h,[["render",p]]);export{q as __pageData,f as default};
