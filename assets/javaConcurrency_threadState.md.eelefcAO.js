import{_ as a,c as e,o as t,a8 as r}from"./chunks/framework.CbRyzB36.js";const m=JSON.parse('{"title":"六、线程状态","description":"","frontmatter":{},"headers":[],"relativePath":"javaConcurrency/threadState.md","filePath":"javaConcurrency/threadState.md"}'),o={name:"javaConcurrency/threadState.md"},p=r('<h1 id="六、线程状态" tabindex="-1">六、线程状态 <a class="header-anchor" href="#六、线程状态" aria-label="Permalink to &quot;六、线程状态&quot;">​</a></h1><p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不 能反映线程在特定操作系统下的状态。</p><h2 id="新建-new" tabindex="-1">新建（NEW） <a class="header-anchor" href="#新建-new" aria-label="Permalink to &quot;新建（NEW）&quot;">​</a></h2><p>创建后尚未启动。</p><h2 id="可运行-runable" tabindex="-1">可运行（RUNABLE） <a class="header-anchor" href="#可运行-runable" aria-label="Permalink to &quot;可运行（RUNABLE）&quot;">​</a></h2><p>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待 资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行 是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</p><h2 id="阻塞-blocked" tabindex="-1">阻塞（BLOCKED） <a class="header-anchor" href="#阻塞-blocked" aria-label="Permalink to &quot;阻塞（BLOCKED）&quot;">​</a></h2><p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占 用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其 他线程释放 monitor lock。</p><h2 id="无限期等待-waiting" tabindex="-1">无限期等待（WAITING） <a class="header-anchor" href="#无限期等待-waiting" aria-label="Permalink to &quot;无限期等待（WAITING）&quot;">​</a></h2><p>等待其它线程显式地唤醒。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主 动的，通过调用 Object.wait() 等方法进入。</p><p>进入方法 退出方法</p><p>没有设置 Timeout 参数的 Object.wait() 方法</p><p>Object.notify() / Object.notifyAll()</p><p>没有设置 Timeout 参数的 Thread.join() 方法</p><p>被调用的线程执行完毕</p><p>LockSupport.park() 方法</p><p>LockSupport.unpark(Thread)</p><h2 id="限期等待-timed-waiting" tabindex="-1">限期等待（TIMED_WAITING） <a class="header-anchor" href="#限期等待-timed-waiting" aria-label="Permalink to &quot;限期等待（TIMED_WAITING）&quot;">​</a></h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>进入方法 退出方法</p><p>Thread.sleep() 方法</p><p>时间结束</p><p>设置了 Timeout 参数的 Object.wait() 方法</p><p>时间结束 / Object.notify() / Object.notifyAll()</p><p>设置了 Timeout 参数的 Thread.join() 方法</p><p>时间结束 / 被调用的线程执行完毕</p><p>LockSupport.parkNanos() 方法 LockSupport.unpark(Thread)</p><p>LockSupport.parkUntil() 方法 LockSupport.unpark(Thread)</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行 描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起 一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><h2 id="死亡-terminated" tabindex="-1">死亡（TERMINATED） <a class="header-anchor" href="#死亡-terminated" aria-label="Permalink to &quot;死亡（TERMINATED）&quot;">​</a></h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p>',32),i=[p];function n(c,h,d,l,s,u){return t(),e("div",null,i)}const k=a(o,[["render",n]]);export{m as __pageData,k as default};
