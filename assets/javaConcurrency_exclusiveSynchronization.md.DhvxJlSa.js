import{_ as a,c as s,o as n,a8 as e}from"./chunks/framework.CbRyzB36.js";const i="/vitepress-java/assets/img_18.DboB1CSN.png",t="/vitepress-java/assets/img_19.zTFGutXJ.png",p="/vitepress-java/assets/img_20.DLHDPKtc.png",l="/vitepress-java/assets/img_21.HgKtR7-n.png",r="/vitepress-java/assets/img_22.E5u8yAKA.png",o="/vitepress-java/assets/img_23.Ds1qXEA8.png",c="/vitepress-java/assets/img_24.DQK5Gekl.png",g="/vitepress-java/assets/img_25.BpOxZWmU.png",d="/vitepress-java/assets/img_26.CGOsYrcH.png",m="/vitepress-java/assets/img_27.CzksfS8s.png",h="/vitepress-java/assets/img_28.Pq9EHNJk.png",_="/vitepress-java/assets/img_29.o96KGk7Q.png",u="/vitepress-java/assets/img_30.H6dFsosx.png",q=JSON.parse('{"title":"四、互斥同步","description":"","frontmatter":{},"headers":[],"relativePath":"javaConcurrency/exclusiveSynchronization.md","filePath":"javaConcurrency/exclusiveSynchronization.md"}'),v={name:"javaConcurrency/exclusiveSynchronization.md"},y=e('<h1 id="四、互斥同步" tabindex="-1">四、互斥同步 <a class="header-anchor" href="#四、互斥同步" aria-label="Permalink to &quot;四、互斥同步&quot;">​</a></h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现 的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h2 id="synchronized" tabindex="-1">synchronized <a class="header-anchor" href="#synchronized" aria-label="Permalink to &quot;synchronized&quot;">​</a></h2><ol><li>同步一个代码块</li></ol><p><img src="'+i+'" alt="img_18.png" loading="lazy"></p><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的 同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线 程就必须等待。</p><p><img src="'+t+'" alt="img_19.png" loading="lazy"></p><p><img src="'+p+'" alt="img_20.png" loading="lazy"></p><p><img src="'+l+'" alt="img_21.png" loading="lazy"></p><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同 步。从输出结果可以看出，两个线程交叉执行。</p><p><img src="'+r+'" alt="img_22.png" loading="lazy"></p><p><img src="'+o+'" alt="img_23.png" loading="lazy"></p><ol start="2"><li>同步一个方法</li></ol><p><img src="'+c+'" alt="img_24.png" loading="lazy"></p><p>它和同步代码块一样，作用于同一个对象。</p><ol start="3"><li>同步一个类</li></ol><p><img src="'+g+'" alt="img_25.png" loading="lazy"></p><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会 进行同步。</p><p><img src="'+d+'" alt="img_26.png" loading="lazy"></p><p><img src="'+m+`" alt="img_27.png" loading="lazy"></p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="4"><li>同步一个静态方法</li></ol><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public synchronized static void fun() {</span></span>
<span class="line"><span>// ...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>作用于整个类。</p><h2 id="reentrantlock" tabindex="-1">ReentrantLock <a class="header-anchor" href="#reentrantlock" aria-label="Permalink to &quot;ReentrantLock&quot;">​</a></h2><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p><p><img src="`+h+'" alt="img_28.png" loading="lazy"></p><p><img src="'+_+'" alt="img_29.png" loading="lazy"></p><p><img src="'+u+'" alt="img_30.png" loading="lazy"></p><div class="language-angular2html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">angular2html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="比较" tabindex="-1">比较 <a class="header-anchor" href="#比较" aria-label="Permalink to &quot;比较&quot;">​</a></h2><ol><li>锁的实现</li></ol><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><ol start="2"><li>性能</li></ol><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><ol start="3"><li>等待可中断</li></ol><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理 其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行</p><ol start="4"><li>公平锁</li></ol><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可 以是公平的。</p><ol start="5"><li>锁绑定多个条件</li></ol><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h2 id="使用选择" tabindex="-1">使用选择 <a class="header-anchor" href="#使用选择" aria-label="Permalink to &quot;使用选择&quot;">​</a></h2><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不 是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁 问题，因为 JVM 会确保锁的释放。</p>',46),b=[y];function k(z,j,C,f,x,J){return n(),s("div",null,b)}const L=a(v,[["render",k]]);export{q as __pageData,L as default};
